<!-- index.html -->
<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YouTube 채널 분석기 (개인용 / 0원 GPT 보강)</title>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- SheetJS (XLSX Export) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <style>
    /* 긴 텍스트(해시태그 등) 줄바꿈 */
    .wrap-anywhere { overflow-wrap: anywhere; word-break: break-word; }
    /* 테이블 헤더 고정 느낌 */
    thead th { position: sticky; top: 0; z-index: 10; background: rgb(15 23 42); }
    /* 토글 스위치 */
    .switch { width: 44px; height: 24px; border-radius: 9999px; position: relative; }
    .switch-dot { width: 20px; height: 20px; border-radius: 9999px; position: absolute; top: 2px; transition: all .15s ease; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>

<body class="bg-slate-950 text-slate-100">
  <div class="max-w-[1400px] mx-auto px-4 py-6">
    <!-- Header -->
    <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold">유튜브 채널 분석기 <span class="text-slate-400 text-sm">(개인용 · 0원 GPT 보강 워크플로우)</span></h1>
        <p class="text-slate-400 mt-1">
          OpenAI API 연동 없이, 유튜브 데이터만으로 분석 → <b>GPT에 붙여넣기용 분석팩/프롬프트</b>를 자동 생성합니다.
        </p>
      </div>

      <div class="flex flex-wrap gap-2">
        <button id="btnOpenProfile" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">
          콘셉트 프로필
        </button>
        <button id="btnCopyPack" class="px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500">
          GPT 분석팩 복사
        </button>
        <button id="btnCopyPrompt" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500">
          GPT 프롬프트 복사
        </button>
        <button id="btnExportXlsx" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">
          XLSX 내보내기
        </button>
      </div>
    </div>

    <!-- Controls -->
    <div class="mt-5 grid grid-cols-1 xl:grid-cols-12 gap-4">
      <!-- Left: Inputs -->
      <div class="xl:col-span-8 bg-slate-900/60 border border-slate-800 rounded-2xl p-4">
        <!-- Mode Toggle -->
        <div class="flex flex-col lg:flex-row gap-3 lg:items-center lg:justify-between">
          <div class="flex flex-wrap gap-2">
            <button data-mode="mine" class="modeBtn px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">내 채널 분석</button>
            <button data-mode="bench" class="modeBtn px-3 py-2 rounded-xl bg-slate-900 hover:bg-slate-800 border border-slate-800">타 채널 벤치마킹</button>
            <button data-mode="compare" class="modeBtn px-3 py-2 rounded-xl bg-slate-900 hover:bg-slate-800 border border-slate-800">Compare</button>
          </div>

          <div class="flex flex-wrap gap-3 items-center">
            <div class="flex items-center gap-2">
              <span class="text-slate-400 text-sm">기준:</span>
              <button id="btnCriteriaProfile" class="px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 text-sm">Profile</button>
              <button id="btnCriteriaAuto" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">Auto</button>
            </div>

            <div class="flex items-center gap-2">
              <span class="text-slate-400 text-sm">데이터 모드:</span>
              <button id="btnDataApi" class="px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 text-sm">API</button>
              <button id="btnDataNoApi" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">No-API</button>
            </div>
          </div>
        </div>

        <!-- Channel inputs -->
        <div class="mt-4 grid grid-cols-1 lg:grid-cols-2 gap-3">
          <div>
            <label class="text-sm text-slate-300">내 채널 입력</label>
            <input id="inputMine" class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-indigo-600"
                   placeholder="예: https://www.youtube.com/@xxxx  또는  @xxxx  또는  UC..." />
            <p class="text-xs text-slate-500 mt-1">URL / @handle / 채널ID(UC...) 자동 판별</p>
          </div>
          <div id="benchWrap" class="hidden">
            <label class="text-sm text-slate-300">벤치 채널 입력</label>
            <input id="inputBench" class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-indigo-600"
                   placeholder="예: https://www.youtube.com/@bench  또는  @bench  또는  UC..." />
            <p class="text-xs text-slate-500 mt-1">Compare 모드에서는 내 채널 vs 벤치 채널을 동시에 수집</p>
          </div>
        </div>

        <!-- API Settings / No-API Settings -->
        <div id="apiSettings" class="mt-4 grid grid-cols-1 lg:grid-cols-3 gap-3">
          <div class="lg:col-span-2">
            <label class="text-sm text-slate-300">프록시 엔드포인트</label>
            <input id="inputProxy" class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-indigo-600"
                   value="/api/youtube" />
            <p class="text-xs text-slate-500 mt-1">
              파일명 충돌 회피하려면 여기만 바꾸면 됩니다 (예: <span class="mono">/api/youtubeProxy</span>).
            </p>
          </div>
          <div>
            <label class="text-sm text-slate-300">캐시 만료(시간)</label>
            <input id="inputCacheHours" type="number" min="0" step="1"
                   class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800 focus:outline-none focus:ring-2 focus:ring-indigo-600"
                   value="6" />
            <p class="text-xs text-slate-500 mt-1">localStorage 캐시 TTL</p>
          </div>
        </div>

        <div id="noApiSettings" class="mt-4 hidden">
          <div class="grid grid-cols-1 lg:grid-cols-3 gap-3">
            <div class="lg:col-span-2">
              <label class="text-sm text-slate-300">CSV 업로드 (No-API)</label>
              <input id="inputCsv" type="file" accept=".csv"
                     class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" />
              <p class="text-xs text-slate-500 mt-1">
                필수 컬럼 예: <span class="mono">videoId,title,publishedAt,views,likes,comments,description,durationSeconds,categoryId,tags</span>
              </p>
            </div>
            <div>
              <label class="text-sm text-slate-300">샘플 데이터</label>
              <button id="btnLoadSample" class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">
                샘플 로드
              </button>
              <p class="text-xs text-slate-500 mt-1">
                No-API는 카테고리/태그/좋아요율 등이 일부 제한될 수 있습니다.
              </p>
            </div>
          </div>
          <div class="mt-3 p-3 rounded-xl bg-amber-950/40 border border-amber-800 text-amber-200 text-sm">
            <b>No-API 모드 제한 고지</b><br/>
            - CTR/유지율 등은 공개 데이터로 불가 → 표시하지 않음<br/>
            - 업로드 시간대/해시태그/태그는 CSV 제공 범위까지만 분석<br/>
            - “채널 입력 자동 판별/해결”은 API 모드에서 가장 정확함
          </div>
        </div>

        <!-- Filters -->
        <div class="mt-5 grid grid-cols-1 lg:grid-cols-12 gap-3">
          <div class="lg:col-span-3">
            <label class="text-sm text-slate-300">콘텐츠 유형</label>
            <select id="selContentType" class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
              <option value="all">전체</option>
              <option value="shorts">쇼츠</option>
              <option value="long">롱폼</option>
            </select>
          </div>

          <div class="lg:col-span-5">
            <label class="text-sm text-slate-300">쇼츠 판별 규칙</label>
            <div class="mt-1 flex gap-2">
              <select id="selShortsRule" class="flex-1 px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
                <option value="duration">A) 길이 기준</option>
                <option value="meta">B) 메타(#shorts 등)</option>
                <option value="hybrid">A+B(OR)</option>
              </select>
              <select id="selShortsThreshold" class="w-32 px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
                <option value="60">60초</option>
                <option value="120">120초</option>
              </select>
            </div>
          </div>

          <div class="lg:col-span-4">
            <label class="text-sm text-slate-300">기간 / 범위</label>
            <div class="mt-1 flex gap-2">
              <select id="selPeriod" class="flex-1 px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
                <option value="7">최근 7일</option>
                <option value="30" selected>최근 30일</option>
                <option value="90">최근 90일</option>
                <option value="365">최근 1년</option>
                <option value="all">전체</option>
              </select>
              <select id="selN" class="w-36 px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
                <option value="10">최근 10개</option>
                <option value="25">최근 25개</option>
                <option value="50" selected>최근 50개</option>
                <option value="100">최근 100개</option>
              </select>
            </div>
          </div>

          <div class="lg:col-span-6">
            <label class="text-sm text-slate-300">조회수 필터</label>
            <div class="mt-1 flex flex-wrap gap-2 items-center">
              <div class="flex gap-2">
                <button class="viewPreset px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm" data-min="100000">10만+</button>
                <button class="viewPreset px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm" data-min="500000">50만+</button>
                <button class="viewPreset px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm" data-min="1000000">100만+</button>
                <button id="btnClearViewPreset" class="px-3 py-2 rounded-xl bg-slate-900 hover:bg-slate-800 border border-slate-800 text-sm">해제</button>
              </div>
              <div class="flex gap-2 items-center">
                <input id="inputMinViews" type="number" min="0" step="1" placeholder="min"
                       class="w-28 px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" />
                <span class="text-slate-500">~</span>
                <input id="inputMaxViews" type="number" min="0" step="1" placeholder="max"
                       class="w-28 px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" />
              </div>
            </div>
          </div>

          <div class="lg:col-span-6">
            <label class="text-sm text-slate-300">쿼터(Quota)</label>
            <div class="mt-1 grid grid-cols-1 md:grid-cols-3 gap-2">
              <div class="p-3 rounded-xl bg-slate-950 border border-slate-800">
                <div class="text-xs text-slate-400">오늘 사용량(추정)</div>
                <div id="quotaUsed" class="text-lg font-semibold">0</div>
              </div>
              <div class="p-3 rounded-xl bg-slate-950 border border-slate-800">
                <div class="text-xs text-slate-400">총 할당량(기본 10,000)</div>
                <input id="quotaLimit" type="number" min="1" step="1"
                       class="mt-1 w-full px-2 py-1 rounded-lg bg-slate-900 border border-slate-700" value="10000" />
              </div>
              <div class="p-3 rounded-xl bg-slate-950 border border-slate-800">
                <div class="text-xs text-slate-400">상태</div>
                <div id="quotaState" class="text-sm text-slate-300 mt-1">정상</div>
              </div>
            </div>

            <div class="mt-2 flex flex-wrap gap-3 items-center">
              <label class="flex items-center gap-2 text-sm">
                <input id="optOnlyN" type="checkbox" class="accent-indigo-500" checked />
                최근 N개만(절약)
              </label>
              <label class="flex items-center gap-2 text-sm">
                <input id="optMinDetails" type="checkbox" class="accent-indigo-500" />
                상세조회 최소화(절약)
              </label>
              <label class="flex items-center gap-2 text-sm">
                <input id="optForceCache" type="checkbox" class="accent-indigo-500" checked />
                캐시 강제 사용
              </label>
            </div>

            <div class="mt-2 text-xs text-slate-500">
              * 로컬 누적 추정치이며, 실제 콘솔 사용량과 약간 다를 수 있습니다.
              (참고: <span class="mono">channels.list=1</span>, <span class="mono">videos.list=1</span>, <span class="mono">search.list=100</span> 등)
            </div>
          </div>
        </div>

        <!-- Run -->
        <div class="mt-5 flex flex-col md:flex-row md:items-center md:justify-between gap-3">
          <button id="btnAnalyze" class="px-4 py-3 rounded-2xl bg-indigo-600 hover:bg-indigo-500 font-semibold">
            분석 실행
          </button>

          <div class="flex items-center gap-3">
            <div class="text-sm text-slate-400">진행:</div>
            <div id="stageLabel" class="text-sm font-medium">대기</div>
            <div class="text-slate-600">|</div>
            <div class="text-sm text-slate-400">경과:</div>
            <div id="elapsed" class="text-sm font-medium">00:00</div>
            <div class="text-slate-600">|</div>
            <div class="w-52 bg-slate-800 rounded-full h-2 overflow-hidden">
              <div id="progressBar" class="bg-emerald-500 h-2 w-0"></div>
            </div>
            <div id="progressPct" class="text-sm font-medium w-12 text-right">0%</div>
          </div>
        </div>

        <div id="errorBox" class="hidden mt-4 p-3 rounded-xl bg-red-950/40 border border-red-800 text-red-200 text-sm"></div>
        <div id="infoBox" class="hidden mt-4 p-3 rounded-xl bg-slate-950 border border-slate-800 text-slate-200 text-sm"></div>
      </div>

      <!-- Right: GPT / Summary -->
      <div class="xl:col-span-4 bg-slate-900/60 border border-slate-800 rounded-2xl p-4">
        <div class="flex items-center justify-between gap-2">
          <h2 class="text-lg font-semibold">GPT 보강 설정</h2>
          <span class="text-xs text-slate-500">복사 → ChatGPT(Plus) 붙여넣기</span>
        </div>

        <div class="mt-3">
          <label class="text-sm text-slate-300">프롬프트 타입</label>
          <select id="selPromptType" class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
            <option value="report">리포트용(1페이지 요약 + 개선안)</option>
            <option value="titles">제목·훅 생성용</option>
            <option value="plan">30일 콘텐츠 플랜용</option>
            <option value="benchRules">벤치마킹 규칙추출용</option>
            <option value="compare">비교 분석용</option>
          </select>
        </div>

        <div class="mt-3 flex items-center justify-between">
          <div>
            <div class="text-sm text-slate-300">출력에 JSON도 포함</div>
            <div class="text-xs text-slate-500">Markdown + JSON 동시 출력 지시</div>
          </div>
          <button id="toggleJsonOut" class="switch bg-indigo-600">
            <div id="toggleJsonDot" class="switch-dot bg-white left-[22px]"></div>
          </button>
        </div>

        <div class="mt-4 p-3 rounded-xl bg-slate-950 border border-slate-800">
          <div class="text-xs text-slate-400 mb-1">요약(분석 결과 일부)</div>
          <div id="miniSummary" class="text-sm text-slate-200 leading-relaxed">
            아직 분석 데이터가 없습니다. <br/>좌측에서 분석을 실행하세요.
          </div>
        </div>

        <div class="mt-4 p-3 rounded-xl bg-slate-950 border border-slate-800">
          <div class="text-xs text-slate-400 mb-2">분석팩/프롬프트 미리보기</div>
          <textarea id="previewText" class="w-full h-44 p-2 rounded-xl bg-slate-900 border border-slate-700 text-xs mono wrap-anywhere"></textarea>
          <div class="text-xs text-slate-500 mt-2">
            * 미리보기는 일부만 표시될 수 있습니다. 복사 버튼을 사용하세요.
          </div>
        </div>
      </div>
    </div>

    <!-- Results -->
    <div class="mt-5 grid grid-cols-1 xl:grid-cols-12 gap-4">
      <!-- KPIs -->
      <div class="xl:col-span-12 bg-slate-900/60 border border-slate-800 rounded-2xl p-4">
        <div class="flex items-center justify-between">
          <h2 class="text-lg font-semibold">현재 상태 진단</h2>
          <div class="text-xs text-slate-500">공개 데이터 기반 · 불가 항목은 “불가/추정 불가”로 표기</div>
        </div>

        <div class="mt-3 grid grid-cols-2 md:grid-cols-4 xl:grid-cols-8 gap-3" id="kpiGrid">
          <!-- Filled by JS -->
        </div>

        <div class="mt-4 grid grid-cols-1 lg:grid-cols-2 gap-3">
          <div class="p-3 rounded-xl bg-slate-950 border border-slate-800">
            <div class="text-sm font-semibold mb-1">좋은 점 / 나쁜 점</div>
            <div id="goodBad" class="text-sm text-slate-200 leading-relaxed">분석 후 표시됩니다.</div>
          </div>
          <div class="p-3 rounded-xl bg-slate-950 border border-slate-800">
            <div class="text-sm font-semibold mb-1">관측된 패턴 요약</div>
            <div id="patterns" class="text-sm text-slate-200 leading-relaxed">분석 후 표시됩니다.</div>
          </div>
        </div>
      </div>

      <!-- Top Videos Table -->
      <div class="xl:col-span-12 bg-slate-900/60 border border-slate-800 rounded-2xl p-4">
        <div class="flex flex-col md:flex-row md:items-end md:justify-between gap-3">
          <div>
            <h2 class="text-lg font-semibold">Top 영상</h2>
            <p class="text-slate-400 text-sm">필터 적용 결과 중 성과 상위 (age-adjusted 기준)</p>
          </div>
          <div class="flex gap-2">
            <input id="topSearch" class="px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" placeholder="검색(제목/해시태그)" />
            <select id="topPageSize" class="px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
              <option value="10">10줄</option>
              <option value="25" selected>25줄</option>
              <option value="50">50줄</option>
            </select>
          </div>
        </div>

        <div class="mt-3 overflow-auto rounded-xl border border-slate-800">
          <table class="min-w-[1200px] w-full text-sm">
            <thead class="text-slate-200">
              <tr id="topHead"></tr>
            </thead>
            <tbody id="topBody" class="bg-slate-950"></tbody>
          </table>
        </div>
        <div class="mt-3 flex items-center justify-between">
          <div id="topPagerInfo" class="text-sm text-slate-400"></div>
          <div class="flex gap-2">
            <button id="topPrev" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">이전</button>
            <button id="topNext" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">다음</button>
          </div>
        </div>
      </div>

      <!-- Underperform -->
      <div class="xl:col-span-12 bg-slate-900/60 border border-slate-800 rounded-2xl p-4">
        <div class="flex flex-col md:flex-row md:items-end md:justify-between gap-3">
          <div>
            <h2 class="text-lg font-semibold">Underperform 진단</h2>
            <p class="text-slate-400 text-sm">동일 포맷(쇼츠/롱폼) 내 age-adjusted 하위권 + 근거 기반 개선안</p>
          </div>
          <div class="flex gap-2">
            <input id="underSearch" class="px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" placeholder="검색(제목/사유)" />
            <select id="underPageSize" class="px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
              <option value="5">5개</option>
              <option value="10" selected>10개</option>
              <option value="20">20개</option>
            </select>
          </div>
        </div>

        <div id="underList" class="mt-3 grid grid-cols-1 gap-3"></div>

        <div class="mt-3 flex items-center justify-between">
          <div id="underPagerInfo" class="text-sm text-slate-400"></div>
          <div class="flex gap-2">
            <button id="underPrev" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">이전</button>
            <button id="underNext" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">다음</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Profile Modal -->
  <div id="profileModal" class="fixed inset-0 hidden items-center justify-center bg-black/60 p-4">
    <div class="w-full max-w-5xl bg-slate-950 border border-slate-800 rounded-2xl overflow-hidden">
      <div class="p-4 border-b border-slate-800 flex items-center justify-between">
        <div>
          <div class="text-lg font-semibold">콘셉트 프로필 (analysis profile)</div>
          <div class="text-xs text-slate-500">새 채널에서도 재사용 가능 · localStorage 저장</div>
        </div>
        <div class="flex gap-2">
          <button id="btnExportProfileJson" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">JSON 내보내기</button>
          <button id="btnImportProfileJson" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">JSON 가져오기</button>
          <button id="btnCloseProfile" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">닫기</button>
        </div>
      </div>

      <div class="p-4 grid grid-cols-1 lg:grid-cols-12 gap-4 max-h-[75vh] overflow-auto">
        <div class="lg:col-span-4 bg-slate-900/50 border border-slate-800 rounded-2xl p-3">
          <div class="flex items-center justify-between">
            <div class="text-sm font-semibold">프로필 목록</div>
            <button id="btnNewProfile" class="px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 text-sm">새 프로필</button>
          </div>
          <div id="profileList" class="mt-3 space-y-2"></div>
        </div>

        <div class="lg:col-span-8 bg-slate-900/50 border border-slate-800 rounded-2xl p-3">
          <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
            <div class="flex-1">
              <label class="text-xs text-slate-400">프로필 이름</label>
              <input id="profileName" class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" />
            </div>
            <div class="flex gap-2">
              <button id="btnSaveProfile" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-sm">저장</button>
              <button id="btnDeleteProfile" class="px-3 py-2 rounded-xl bg-red-600 hover:bg-red-500 text-sm">삭제</button>
            </div>
          </div>

          <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-3">
            <div class="p-3 rounded-xl bg-slate-950 border border-slate-800">
              <div class="text-sm font-semibold mb-2">1) 장르/토픽 가중치 (0~5)</div>
              <div id="weightGrid" class="grid grid-cols-2 gap-2 text-sm"></div>
              <div class="mt-3 flex gap-2">
                <input id="newWeightKey" class="flex-1 px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 text-sm" placeholder="커스텀 항목(예: 과학)" />
                <button id="btnAddWeightKey" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">추가</button>
              </div>
            </div>

            <div class="p-3 rounded-xl bg-slate-950 border border-slate-800">
              <div class="text-sm font-semibold mb-2">2) 타깃 슬라이더</div>
              <div class="space-y-3 text-sm">
                <div>
                  <div class="flex items-center justify-between"><span>연령 10대</span><span id="age10v" class="text-slate-400">0</span></div>
                  <input id="age10" type="range" min="0" max="100" value="15" class="w-full accent-indigo-500" />
                </div>
                <div>
                  <div class="flex items-center justify-between"><span>연령 20대</span><span id="age20v" class="text-slate-400">0</span></div>
                  <input id="age20" type="range" min="0" max="100" value="35" class="w-full accent-indigo-500" />
                </div>
                <div>
                  <div class="flex items-center justify-between"><span>연령 30대</span><span id="age30v" class="text-slate-400">0</span></div>
                  <input id="age30" type="range" min="0" max="100" value="35" class="w-full accent-indigo-500" />
                </div>
                <div>
                  <div class="flex items-center justify-between"><span>연령 40대</span><span id="age40v" class="text-slate-400">0</span></div>
                  <input id="age40" type="range" min="0" max="100" value="15" class="w-full accent-indigo-500" />
                </div>

                <div class="mt-2 border-t border-slate-800 pt-3">
                  <div class="flex items-center justify-between"><span>성별 남성</span><span id="malev" class="text-slate-400">0</span></div>
                  <input id="male" type="range" min="0" max="100" value="50" class="w-full accent-indigo-500" />
                  <div class="flex items-center justify-between mt-2"><span>성별 여성</span><span id="femalev" class="text-slate-400">0</span></div>
                  <input id="female" type="range" min="0" max="100" value="50" class="w-full accent-indigo-500" />
                </div>
              </div>
            </div>

            <div class="p-3 rounded-xl bg-slate-950 border border-slate-800 md:col-span-2">
              <div class="text-sm font-semibold mb-2">3) 쇼츠 포맷 룰</div>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
                <div class="p-3 rounded-xl bg-slate-900 border border-slate-700">
                  <div class="text-xs text-slate-400">쇼츠 길이 임계값</div>
                  <select id="pfShortThreshold" class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
                    <option value="60">60초</option>
                    <option value="120">120초</option>
                  </select>
                </div>

                <div class="p-3 rounded-xl bg-slate-900 border border-slate-700">
                  <div class="text-xs text-slate-400">훅 타입 선호</div>
                  <select id="pfHookPref" class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
                    <option value="question">의문형</option>
                    <option value="twist">반전형</option>
                    <option value="dialog">대사형</option>
                    <option value="situation" selected>상황요약형</option>
                  </select>
                </div>

                <div class="p-3 rounded-xl bg-slate-900 border border-slate-700">
                  <div class="text-xs text-slate-400">제목 길이</div>
                  <select id="pfTitleLen" class="mt-1 w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800">
                    <option value="short">짧게</option>
                    <option value="normal" selected>보통</option>
                    <option value="long">길게</option>
                  </select>
                </div>

                <div class="p-3 rounded-xl bg-slate-900 border border-slate-700">
                  <div class="text-xs text-slate-400">제목 스타일 토글</div>
                  <div class="mt-2 grid grid-cols-2 gap-2">
                    <label class="flex items-center gap-2"><input id="pfEmo" type="checkbox" class="accent-indigo-500" checked />감정단어 선호</label>
                    <label class="flex items-center gap-2"><input id="pfNums" type="checkbox" class="accent-indigo-500" checked />숫자 구조</label>
                    <label class="flex items-center gap-2"><input id="pfContrast" type="checkbox" class="accent-indigo-500" checked />대비/반전</label>
                    <label class="flex items-center gap-2"><input id="pfQuestion" type="checkbox" class="accent-indigo-500" checked />의문형</label>
                  </div>
                </div>
              </div>
            </div>

            <div class="p-3 rounded-xl bg-slate-950 border border-slate-800 md:col-span-2">
              <div class="text-sm font-semibold mb-2">4) 금지/경고 키워드 (발견 시 감점/경고)</div>
              <textarea id="pfForbidden" class="w-full h-24 p-2 rounded-xl bg-slate-900 border border-slate-700 text-sm mono"
                        placeholder="줄바꿈으로 입력 (예: 혐오, 정치, 도박 등)"></textarea>
              <div class="text-xs text-slate-500 mt-2">분석 리포트에서 “왜 경고인지”를 함께 표시합니다.</div>
            </div>
          </div>

          <div class="mt-3 p-3 rounded-xl bg-slate-950 border border-slate-800">
            <div class="text-sm font-semibold mb-1">프로필 저장/불러오기 안내</div>
            <div class="text-sm text-slate-200">
              - 기본값은 “Profile 기준 평가”이며, Auto는 채널 데이터로 단순 휴리스틱 학습을 합니다.<br/>
              - 새 채널 운영 시, 프로필 JSON만 가져오면 동일 분석 기준으로 재사용 가능합니다.
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Export Modal -->
  <div id="exportModal" class="fixed inset-0 hidden items-center justify-center bg-black/60 p-4">
    <div class="w-full max-w-xl bg-slate-950 border border-slate-800 rounded-2xl overflow-hidden">
      <div class="p-4 border-b border-slate-800 flex items-center justify-between">
        <div class="text-lg font-semibold">XLSX 내보내기</div>
        <button id="btnCloseExport" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">닫기</button>
      </div>
      <div class="p-4 space-y-3">
        <label class="flex items-center gap-2">
          <input id="expCurrent" type="radio" name="expScope" class="accent-indigo-500" checked />
          현재 필터 결과만
        </label>
        <label class="flex items-center gap-2">
          <input id="expAll" type="radio" name="expScope" class="accent-indigo-500" />
          전체 결과(수집된 범위)
        </label>
        <button id="btnDoExport" class="w-full px-4 py-3 rounded-2xl bg-emerald-600 hover:bg-emerald-500 font-semibold">
          다운로드 시작
        </button>
        <div class="text-xs text-slate-500">
          SheetJS(CDN) 기반. 브라우저에서 바로 다운로드됩니다.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ========= Helpers =========
  const $ = (id) => document.getElementById(id);
  const fmt = new Intl.NumberFormat('ko-KR');
  const pad2 = (n) => String(n).padStart(2,'0');
  const now = () => new Date();
  const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
  const safeDiv = (a,b) => (b && isFinite(a/b)) ? a/b : null;

  function toISODate(d) {
    const x = new Date(d);
    if (isNaN(x)) return null;
    return x.toISOString();
  }

  function ageDays(publishedAt) {
    const t = new Date(publishedAt).getTime();
    if (!isFinite(t)) return null;
    const diff = Date.now() - t;
    return Math.max(0, diff / (1000*60*60*24));
  }

  function parseISODurationToSeconds(iso) {
    // PT#H#M#S
    if (!iso || typeof iso !== 'string') return null;
    const m = iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!m) return null;
    const h = Number(m[1]||0), mi = Number(m[2]||0), s = Number(m[3]||0);
    return h*3600 + mi*60 + s;
  }

  function extractHashtags(text) {
    if (!text) return [];
    // Korean hashtags: allow letters/digits/underscore + hangul
    const re = /#[0-9A-Za-z_가-힣]+/g;
    const m = text.match(re);
    if (!m) return [];
    // unique preserve order
    const seen = new Set();
    const out = [];
    for (const tag of m) {
      const t = tag.trim();
      if (!seen.has(t.toLowerCase())) { seen.add(t.toLowerCase()); out.push(t); }
    }
    return out;
  }

  function stripUrls(text) {
    if (!text) return '';
    return text.replace(/https?:\/\/\S+/g, ' ');
  }

  function tokenize(text) {
    if (!text) return [];
    const cleaned = stripUrls(text)
      .replace(/[^\p{L}\p{N}\s]/gu, ' ')
      .toLowerCase();
    const raw = cleaned.split(/\s+/).filter(Boolean);
    const stop = new Set([
      "그리고","그래서","근데","하지만","그런데","진짜","이거","저거","그거","오늘","내가","너가","너는","나는","우리","이런","저런",
      "the","a","an","and","or","to","of","in","on","for","with","is","are","was","were","be","been","it","this","that","as"
    ]);
    const out = [];
    for (const w of raw) {
      if (w.length < 2) continue;
      if (stop.has(w)) continue;
      out.push(w);
    }
    return out;
  }

  function median(arr) {
    const a = arr.filter(v => v!=null && isFinite(v)).slice().sort((x,y)=>x-y);
    if (!a.length) return null;
    const mid = Math.floor(a.length/2);
    return (a.length%2) ? a[mid] : (a[mid-1]+a[mid])/2;
  }

  function pct(arr, p) {
    const a = arr.filter(v => v!=null && isFinite(v)).slice().sort((x,y)=>x-y);
    if (!a.length) return null;
    const idx = (a.length-1)*p;
    const lo = Math.floor(idx), hi = Math.ceil(idx);
    if (lo===hi) return a[lo];
    return a[lo] + (a[hi]-a[lo])*(idx-lo);
  }

  function debounce(fn, ms=250) {
    let t=null;
    return (...args) => {
      clearTimeout(t);
      t=setTimeout(()=>fn(...args), ms);
    };
  }

  async function copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      toast("클립보드에 복사했습니다");
    } catch {
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      toast("클립보드에 복사했습니다(폴백)");
    }
  }

  function toast(msg) {
    const el = document.createElement('div');
    el.className = "fixed bottom-4 right-4 z-[9999] bg-slate-900 border border-slate-700 text-slate-100 px-4 py-3 rounded-2xl shadow-xl";
    el.textContent = msg;
    document.body.appendChild(el);
    setTimeout(()=>el.remove(), 2200);
  }

  function setError(msg) {
    const box = $("errorBox");
    box.classList.remove("hidden");
    box.innerHTML = msg;
  }
  function clearError() {
    const box = $("errorBox");
    box.classList.add("hidden");
    box.innerHTML = "";
  }
  function setInfo(msg) {
    const box = $("infoBox");
    box.classList.remove("hidden");
    box.innerHTML = msg;
  }
  function clearInfo() {
    const box = $("infoBox");
    box.classList.add("hidden");
    box.innerHTML = "";
  }

  // ========= State =========
  const LS = {
    QUOTA: "ytAnalyzer.quota",
    PROFILES: "ytAnalyzer.profiles",
    ACTIVE_PROFILE: "ytAnalyzer.activeProfileId",
    CACHE: "ytAnalyzer.cache.v1",
    UI: "ytAnalyzer.ui",
  };

  const QUOTA_COST = {
    "channels.list": 1,
    "playlistItems.list": 1,
    "videos.list": 1,
    "videoCategories.list": 1,
    "search.list": 100,
  };

  const state = {
    mode: "mine",              // mine | bench | compare
    criteria: "profile",       // profile | auto
    dataMode: "api",           // api | noapi
    jsonOut: true,

    quotaUsed: 0,
    quotaLimit: 10000,

    progress: { stage: "대기", pct: 0, startAt: null, timer: null },

    profiles: [],
    activeProfileId: null,

    dataset: { mine: null, bench: null }, // {channel, videos[], categoriesMap}
    report: { mine: null, bench: null, compare: null },

    tables: {
      top: { sortKey: "score", sortDir: "desc", page: 1, pageSize: 25, query: "" },
      under: { page: 1, pageSize: 10, query: "" }
    },

    lastPack: null,
    lastPrompt: null,
  };

  // ========= Default Profile =========
  function makeDefaultProfile() {
    return {
      id: "pf_" + Math.random().toString(36).slice(2,10),
      name: "기본(썰 쇼츠 멀티장르)",
      weights: {
        "연애": 5, "막장": 4, "코미디": 5, "호기심": 4, "공감": 4,
        "직장": 3, "가족": 2, "친구": 2, "돈": 3, "미스터리": 2
      },
      target: {
        age10: 15, age20: 35, age30: 35, age40: 15,
        male: 50, female: 50
      },
      shortsRules: {
        thresholdSec: 60,
        hookPref: "situation", // question | twist | dialog | situation
        titleLen: "normal",    // short | normal | long
        preferEmotion: true,
        preferNumbers: true,
        preferContrast: true,
        preferQuestion: true
      },
      forbidden: ["혐오","차별","불법","도박","정치선동"]
    };
  }

  function loadProfiles() {
    const raw = localStorage.getItem(LS.PROFILES);
    const activeId = localStorage.getItem(LS.ACTIVE_PROFILE);
    let profiles = [];
    try { profiles = raw ? JSON.parse(raw) : []; } catch { profiles = []; }

    if (!profiles.length) profiles = [makeDefaultProfile()];
    state.profiles = profiles;

    state.activeProfileId = (activeId && profiles.some(p=>p.id===activeId)) ? activeId : profiles[0].id;
    localStorage.setItem(LS.ACTIVE_PROFILE, state.activeProfileId);
    saveProfiles(false);
  }

  function saveProfiles(saveActive=true) {
    localStorage.setItem(LS.PROFILES, JSON.stringify(state.profiles));
    if (saveActive) localStorage.setItem(LS.ACTIVE_PROFILE, state.activeProfileId);
  }

  function getActiveProfile() {
    return state.profiles.find(p=>p.id===state.activeProfileId) || state.profiles[0];
  }

  // ========= UI Init =========
  function setMode(mode) {
    state.mode = mode;
    document.querySelectorAll(".modeBtn").forEach(b=>{
      const is = b.dataset.mode===mode;
      b.className = "modeBtn px-3 py-2 rounded-xl border text-sm " + (is ? "bg-slate-800 hover:bg-slate-700 border-slate-700" : "bg-slate-900 hover:bg-slate-800 border-slate-800");
    });
    $("benchWrap").classList.toggle("hidden", mode==="mine");
  }

  function setCriteria(c) {
    state.criteria = c;
    if (c==="profile") {
      $("btnCriteriaProfile").className = "px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 text-sm";
      $("btnCriteriaAuto").className = "px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm";
    } else {
      $("btnCriteriaAuto").className = "px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 text-sm";
      $("btnCriteriaProfile").className = "px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm";
    }
  }

  function setDataMode(m) {
    state.dataMode = m;
    if (m==="api") {
      $("btnDataApi").className = "px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 text-sm";
      $("btnDataNoApi").className = "px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm";
      $("apiSettings").classList.remove("hidden");
      $("noApiSettings").classList.add("hidden");
    } else {
      $("btnDataNoApi").className = "px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 text-sm";
      $("btnDataApi").className = "px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm";
      $("noApiSettings").classList.remove("hidden");
      $("apiSettings").classList.add("hidden");
    }
  }

  function toggleJsonOut(on) {
    state.jsonOut = on;
    $("toggleJsonOut").className = "switch " + (on ? "bg-indigo-600" : "bg-slate-700");
    $("toggleJsonDot").style.left = on ? "22px" : "2px";
  }

  function setStage(stage, pct=null) {
    state.progress.stage = stage;
    $("stageLabel").textContent = stage;
    if (pct!=null) setProgress(pct);
  }

  function setProgress(pct) {
    state.progress.pct = clamp(Math.round(pct), 0, 100);
    $("progressPct").textContent = state.progress.pct + "%";
    $("progressBar").style.width = state.progress.pct + "%";
  }

  function startTimer() {
    stopTimer();
    state.progress.startAt = Date.now();
    state.progress.timer = setInterval(()=>{
      const s = Math.floor((Date.now()-state.progress.startAt)/1000);
      const mm = Math.floor(s/60), ss = s%60;
      $("elapsed").textContent = `${pad2(mm)}:${pad2(ss)}`;
    }, 200);
  }
  function stopTimer() {
    if (state.progress.timer) clearInterval(state.progress.timer);
    state.progress.timer = null;
    $("elapsed").textContent = "00:00";
  }

  function loadQuota() {
    const raw = localStorage.getItem(LS.QUOTA);
    let q = { used: 0, limit: 10000, date: new Date().toISOString().slice(0,10) };
    try { if (raw) q = JSON.parse(raw); } catch {}
    const today = new Date().toISOString().slice(0,10);
    if (q.date !== today) q.used = 0, q.date = today;
    state.quotaUsed = q.used ?? 0;
    state.quotaLimit = q.limit ?? 10000;
    $("quotaLimit").value = state.quotaLimit;
    renderQuota();
  }

  function saveQuota() {
    const today = new Date().toISOString().slice(0,10);
    localStorage.setItem(LS.QUOTA, JSON.stringify({ used: state.quotaUsed, limit: state.quotaLimit, date: today }));
  }

  function addQuota(endpointKey, units=1) {
    const cost = (QUOTA_COST[endpointKey] ?? 1) * units;
    state.quotaUsed += cost;
    renderQuota();
    saveQuota();
  }

  function renderQuota() {
    $("quotaUsed").textContent = fmt.format(state.quotaUsed);
    $("quotaLimit").value = state.quotaLimit;
    const remain = state.quotaLimit - state.quotaUsed;
    if (remain <= 0) {
      $("quotaState").textContent = "초과(추정) · 쿼터 절약 옵션 또는 다음날(PT 기준) 재시도";
      $("quotaState").className = "text-sm mt-1 text-red-300";
    } else if (remain < state.quotaLimit * 0.1) {
      $("quotaState").textContent = "주의(10% 미만 남음)";
      $("quotaState").className = "text-sm mt-1 text-amber-300";
    } else {
      $("quotaState").textContent = "정상";
      $("quotaState").className = "text-sm mt-1 text-slate-300";
    }
  }

  function loadUIState() {
    const raw = localStorage.getItem(LS.UI);
    if (!raw) return;
    try {
      const u = JSON.parse(raw);
      if (u.mode) setMode(u.mode);
      if (u.criteria) setCriteria(u.criteria);
      if (u.dataMode) setDataMode(u.dataMode);
      if (u.jsonOut!=null) toggleJsonOut(!!u.jsonOut);
    } catch {}
  }
  function saveUIState() {
    localStorage.setItem(LS.UI, JSON.stringify({ mode: state.mode, criteria: state.criteria, dataMode: state.dataMode, jsonOut: state.jsonOut }));
  }

  // ========= Profile Modal =========
  function openProfileModal() {
    renderProfileList();
    loadProfileToEditor(getActiveProfile());
    $("profileModal").classList.remove("hidden");
    $("profileModal").classList.add("flex");
  }
  function closeProfileModal() {
    $("profileModal").classList.add("hidden");
    $("profileModal").classList.remove("flex");
  }

  function renderProfileList() {
    const wrap = $("profileList");
    wrap.innerHTML = "";
    for (const p of state.profiles) {
      const active = p.id === state.activeProfileId;
      const btn = document.createElement("button");
      btn.className = "w-full text-left px-3 py-2 rounded-xl border " + (active ? "bg-indigo-600/20 border-indigo-600" : "bg-slate-950 border-slate-800 hover:bg-slate-900");
      btn.innerHTML = `<div class="text-sm font-semibold">${escapeHtml(p.name)}</div><div class="text-xs text-slate-400 mono">${p.id}</div>`;
      btn.onclick = () => {
        state.activeProfileId = p.id;
        saveProfiles(true);
        renderProfileList();
        loadProfileToEditor(p);
        toast("프로필 선택: " + p.name);
      };
      wrap.appendChild(btn);
    }
  }

  function escapeHtml(s) {
    return String(s??"").replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c]));
  }

  function loadProfileToEditor(p) {
    $("profileName").value = p.name ?? "";
    // weights
    renderWeightGrid(p);
    // target
    setSlider("age10", p.target.age10);
    setSlider("age20", p.target.age20);
    setSlider("age30", p.target.age30);
    setSlider("age40", p.target.age40);
    setSlider("male", p.target.male);
    setSlider("female", p.target.female);
    // rules
    $("pfShortThreshold").value = String(p.shortsRules.thresholdSec ?? 60);
    $("pfHookPref").value = p.shortsRules.hookPref ?? "situation";
    $("pfTitleLen").value = p.shortsRules.titleLen ?? "normal";
    $("pfEmo").checked = !!p.shortsRules.preferEmotion;
    $("pfNums").checked = !!p.shortsRules.preferNumbers;
    $("pfContrast").checked = !!p.shortsRules.preferContrast;
    $("pfQuestion").checked = !!p.shortsRules.preferQuestion;
    // forbidden
    $("pfForbidden").value = (p.forbidden ?? []).join("\n");
  }

  function setSlider(id, v) {
    const el = $(id);
    el.value = String(clamp(Number(v??0),0,100));
    const valSpan = $(id+"v");
    if (valSpan) valSpan.textContent = el.value;
  }

  function renderWeightGrid(p) {
    const grid = $("weightGrid");
    grid.innerHTML = "";
    const keys = Object.keys(p.weights || {}).sort((a,b)=>a.localeCompare(b,'ko'));
    for (const k of keys) {
      const row = document.createElement("div");
      row.className = "flex items-center gap-2 bg-slate-900 border border-slate-800 rounded-xl px-2 py-2";
      row.innerHTML = `
        <div class="flex-1">${escapeHtml(k)}</div>
        <input data-wkey="${escapeHtml(k)}" type="number" min="0" max="5" step="1"
               class="w-16 px-2 py-1 rounded-lg bg-slate-950 border border-slate-700 text-sm" value="${p.weights[k]}"/>
        <button data-delkey="${escapeHtml(k)}" class="px-2 py-1 rounded-lg bg-slate-800 hover:bg-slate-700 border border-slate-700 text-xs">삭제</button>
      `;
      grid.appendChild(row);
    }

    grid.querySelectorAll("input[data-wkey]").forEach(inp=>{
      inp.oninput = () => {
        const key = inp.dataset.wkey;
        const prof = getActiveProfile();
        prof.weights[key] = clamp(Number(inp.value||0),0,5);
      };
    });
    grid.querySelectorAll("button[data-delkey]").forEach(btn=>{
      btn.onclick = () => {
        const key = btn.dataset.delkey;
        const prof = getActiveProfile();
        delete prof.weights[key];
        renderWeightGrid(prof);
      };
    });
  }

  function saveEditorToProfile() {
    const prof = getActiveProfile();
    prof.name = $("profileName").value.trim() || prof.name;

    prof.target.age10 = Number($("age10").value);
    prof.target.age20 = Number($("age20").value);
    prof.target.age30 = Number($("age30").value);
    prof.target.age40 = Number($("age40").value);
    prof.target.male = Number($("male").value);
    prof.target.female = Number($("female").value);

    prof.shortsRules.thresholdSec = Number($("pfShortThreshold").value);
    prof.shortsRules.hookPref = $("pfHookPref").value;
    prof.shortsRules.titleLen = $("pfTitleLen").value;
    prof.shortsRules.preferEmotion = $("pfEmo").checked;
    prof.shortsRules.preferNumbers = $("pfNums").checked;
    prof.shortsRules.preferContrast = $("pfContrast").checked;
    prof.shortsRules.preferQuestion = $("pfQuestion").checked;

    prof.forbidden = $("pfForbidden").value.split("\n").map(s=>s.trim()).filter(Boolean);

    saveProfiles(true);
    renderProfileList();
  }

  // ========= Parsing channel input =========
  function normalizeChannelInput(raw) {
    const v = (raw||"").trim();
    if (!v) return { kind: "empty" };

    // channel ID
    if (/^UC[0-9A-Za-z_-]{20,}$/.test(v)) return { kind: "channelId", channelId: v };

    // handle
    if (/^@[\w.-]{2,}$/.test(v)) return { kind: "handle", handle: v };

    // URL
    try {
      const u = new URL(v);
      if (!/youtube\.com$/.test(u.hostname) && !/www\.youtube\.com$/.test(u.hostname) && !/m\.youtube\.com$/.test(u.hostname)) {
        return { kind: "unknown", raw: v };
      }
      const path = u.pathname || "";
      // /channel/UC...
      const m1 = path.match(/\/channel\/(UC[0-9A-Za-z_-]+)/);
      if (m1) return { kind: "channelId", channelId: m1[1] };

      // /@handle
      const m2 = path.match(/\/@([\w.-]+)/);
      if (m2) return { kind: "handle", handle: "@"+m2[1] };

      // /user/xxx or /c/xxx (fallback)
      const m3 = path.match(/\/(user|c)\/([^/]+)/);
      if (m3) return { kind: "customUrl", custom: m3[2] };

      return { kind: "unknownUrl", raw: v };
    } catch {
      // plain string -> try handle without @?
      if (/^[\w.-]{2,}$/.test(v)) return { kind: "maybeHandle", value: v };
      return { kind: "unknown", raw: v };
    }
  }

  // ========= API Fetch (proxy) =========
  async function fetchProxy(params, { endpointKey, cacheKey, cacheHours, forceCache }) {
    const base = ($("inputProxy").value || "/api/youtube").trim();
    const url = new URL(base, window.location.origin);
    Object.entries(params).forEach(([k,v]) => { if (v!=null) url.searchParams.set(k, String(v)); });

    const ttlMs = Math.max(0, Number(cacheHours||0)) * 3600 * 1000;
    const cache = loadCache();

    if (forceCache && cacheKey && ttlMs>0) {
      const hit = cache[cacheKey];
      if (hit && (Date.now() - hit.at) < ttlMs) return hit.data;
    }

    // quota (local estimate)
    if (endpointKey) addQuota(endpointKey, 1);

    const data = await fetchWithRetry(url.toString(), { method: "GET" }, 3);

    if (forceCache && cacheKey && ttlMs>0) {
      cache[cacheKey] = { at: Date.now(), data };
      saveCache(cache);
    }
    return data;
  }

  async function fetchWithRetry(url, options, tries=3) {
    let lastErr = null;
    for (let i=0; i<tries; i++) {
      try {
        const res = await fetch(url, options);
        const txt = await res.text();
        let json = null;
        try { json = JSON.parse(txt); } catch {}
        if (!res.ok) {
          const msg = (json && (json.message||json.error?.message)) ? (json.message||json.error.message) : txt;
          throw new Error(`HTTP ${res.status}: ${msg}`);
        }
        return json ?? {};
      } catch (e) {
        lastErr = e;
        await new Promise(r => setTimeout(r, 250 * Math.pow(2,i)));
      }
    }
    throw lastErr;
  }

  function loadCache() {
    const raw = localStorage.getItem(LS.CACHE);
    try { return raw ? JSON.parse(raw) : {}; } catch { return {}; }
  }
  function saveCache(obj) {
    try { localStorage.setItem(LS.CACHE, JSON.stringify(obj)); } catch {}
  }

  // ========= Data Acquisition =========
  async function resolveChannelId(inputObj, cacheHours, forceCache) {
    // returns { channelId, resolvedBy, debug }
    if (inputObj.kind === "channelId") {
      return { channelId: inputObj.channelId, resolvedBy: "channelId" };
    }

    if (state.dataMode !== "api") {
      throw new Error("No-API 모드에서는 채널 자동 식별이 제한됩니다. CSV 업로드 또는 샘플 로드를 사용하세요.");
    }

    if (inputObj.kind === "handle") {
      const handle = inputObj.handle;
      const cacheKey = `ch_forHandle:${handle}`;
      const json = await fetchProxy({
        op: "channels.list",
        part: "id",
        forHandle: handle
      }, { endpointKey: "channels.list", cacheKey, cacheHours, forceCache });

      const item = json?.items?.[0];
      if (!item?.id) throw new Error(`핸들로 채널을 찾지 못했습니다: ${handle}`);
      return { channelId: item.id, resolvedBy: "forHandle" };
    }

    if (inputObj.kind === "maybeHandle") {
      // try forHandle first (cheap: 1)
      const handle = "@"+inputObj.value;
      try {
        const cacheKey = `ch_forHandle:${handle}`;
        const json = await fetchProxy({
          op: "channels.list",
          part: "id",
          forHandle: handle
        }, { endpointKey: "channels.list", cacheKey, cacheHours, forceCache });
        const item = json?.items?.[0];
        if (item?.id) return { channelId: item.id, resolvedBy: "forHandle(guess)" };
      } catch {}
      // fallback search.list (expensive: 100)
      const q = inputObj.value;
      const cacheKey2 = `ch_search:${q}`;
      const json2 = await fetchProxy({
        op: "search.list",
        part: "snippet",
        type: "channel",
        q,
        maxResults: 1
      }, { endpointKey: "search.list", cacheKey: cacheKey2, cacheHours, forceCache });

      const it = json2?.items?.[0];
      const cid = it?.snippet?.channelId;
      if (!cid) throw new Error(`채널 식별 실패: "${q}"\n- 해결: @handle 또는 채널ID(UC...)로 다시 시도하거나, 핸들 오타를 확인하세요.`);
      return { channelId: cid, resolvedBy: "search.list" };
    }

    if (inputObj.kind === "customUrl") {
      // fallback search
      const q = inputObj.custom;
      const cacheKey = `ch_search_custom:${q}`;
      const json = await fetchProxy({
        op: "search.list",
        part: "snippet",
        type: "channel",
        q,
        maxResults: 1
      }, { endpointKey: "search.list", cacheKey, cacheHours, forceCache });

      const it = json?.items?.[0];
      const cid = it?.snippet?.channelId;
      if (!cid) throw new Error(`커스텀 URL 기반 식별 실패: "${q}"\n- 해결: 채널 URL을 /@handle 형식으로 다시 복사하거나, 채널ID(UC...)를 입력하세요.`);
      return { channelId: cid, resolvedBy: "search.list(custom)" };
    }

    throw new Error(`채널 입력을 인식하지 못했습니다.\n- 해결: @handle 또는 채널ID(UC...)를 입력해보세요.`);
  }

  async function fetchChannelBundle(channelId, cacheHours, forceCache) {
    // channel details
    const chKey = `channels:${channelId}`;
    const ch = await fetchProxy({
      op: "channels.list",
      part: "snippet,statistics,contentDetails",
      id: channelId
    }, { endpointKey: "channels.list", cacheKey: chKey, cacheHours, forceCache });

    const channel = ch?.items?.[0];
    if (!channel) throw new Error(`채널 정보를 가져오지 못했습니다: ${channelId}`);

    const uploads = channel?.contentDetails?.relatedPlaylists?.uploads;
    if (!uploads) throw new Error("업로드 플레이리스트(uploads) 정보를 찾지 못했습니다.");

    // category map
    const catKey = `videoCategories:KR`;
    const cats = await fetchProxy({
      op: "videoCategories.list",
      part: "snippet",
      regionCode: "KR"
    }, { endpointKey: "videoCategories.list", cacheKey: catKey, cacheHours, forceCache });
    const categoriesMap = {};
    for (const it of (cats?.items||[])) {
      categoriesMap[it.id] = it?.snippet?.title || it.id;
    }

    // playlist items (recent N)
    const wantN = Number($("selN").value);
    const onlyN = $("optOnlyN").checked;
    const maxNeed = onlyN ? wantN : wantN; // still bounded by UI N (필수 요구사항이 N 범위)
    const ids = [];
    let pageToken = null;

    setStage("수집(playlistItems)", 10);
    let pageCount = 0;

    while (ids.length < maxNeed) {
      pageCount++;
      const plKey = `pl:${uploads}:pt:${pageToken||"first"}:n:${maxNeed}`;
      const pl = await fetchProxy({
        op: "playlistItems.list",
        part: "contentDetails,snippet",
        playlistId: uploads,
        maxResults: 50,
        pageToken: pageToken || undefined
      }, { endpointKey: "playlistItems.list", cacheKey: plKey, cacheHours, forceCache });

      const items = pl?.items || [];
      for (const it of items) {
        const vid = it?.contentDetails?.videoId;
        if (vid) ids.push(vid);
        if (ids.length >= maxNeed) break;
      }

      pageToken = pl?.nextPageToken;
      setProgress(10 + Math.min(35, Math.round((ids.length / maxNeed)*35)));

      if (!pageToken || !items.length) break;
    }

    // video details (batch 50)
    const minDetails = $("optMinDetails").checked;
    const parts = minDetails ? "snippet,statistics,contentDetails" : "snippet,statistics,contentDetails";
    // (확장 포인트) topicDetails/status 등은 일단 제외 — 공개 분석에 필수는 아니라서
    setStage("수집(videos)", 50);

    const videos = [];
    for (let i=0; i<ids.length; i+=50) {
      const batch = ids.slice(i, i+50);
      const vKey = `videos:${batch.join(",")}:${parts}`;
      const v = await fetchProxy({
        op: "videos.list",
        part: parts,
        id: batch.join(",")
      }, { endpointKey: "videos.list", cacheKey: vKey, cacheHours, forceCache });

      for (const it of (v?.items || [])) videos.push(it);

      const done = i + batch.length;
      setProgress(50 + Math.round((done/ids.length)*30));
    }

    return { channel, videos, categoriesMap };
  }

  // ========= Filtering & Classification =========
  function classifyIsShorts(v, rule, thresholdSec) {
    const dur = v.durationSeconds;
    const title = v.title || "";
    const desc = v.description || "";
    const metaHit = /#shorts\b|#Shorts\b|#SHORTS\b|쇼츠|shorts/i.test(title + " " + desc);

    const lenHit = (dur!=null && dur <= thresholdSec);
    if (rule==="duration") return lenHit;
    if (rule==="meta") return metaHit;
    return (lenHit || metaHit);
  }

  function applyFilters(videos) {
    const type = $("selContentType").value; // all|shorts|long
    const rule = $("selShortsRule").value;
    const threshold = Number($("selShortsThreshold").value);

    const period = $("selPeriod").value;
    const periodDays = period==="all" ? null : Number(period);

    const minViews = $("inputMinViews").value ? Number($("inputMinViews").value) : null;
    const maxViews = $("inputMaxViews").value ? Number($("inputMaxViews").value) : null;

    const nowMs = Date.now();
    const out = [];

    for (const v of videos) {
      const isShort = classifyIsShorts(v, rule, threshold);
      if (type==="shorts" && !isShort) continue;
      if (type==="long" && isShort) continue;

      if (periodDays!=null) {
        const t = new Date(v.publishedAt).getTime();
        if (!isFinite(t)) continue;
        const diffDays = (nowMs - t) / (1000*60*60*24);
        if (diffDays > periodDays) continue;
      }

      const views = v.views ?? 0;
      if (minViews!=null && views < minViews) continue;
      if (maxViews!=null && views > maxViews) continue;

      out.push(v);
    }
    return out;
  }

  // ========= Heuristics (title/hashtags/schedule/profile) =========
  const EMO_WORDS = ["미쳤","충격","눈물","화남","짜증","설렘","레전드","최악","최고","소름","당황","현타","빡침","감동","웃김","폭소"];
  const CONTRAST_WORDS = ["근데","하지만","그런데","반전","사실","알고보니","vs","대신","오히려"];

  function titleSignals(title) {
    const t = title || "";
    const len = t.replace(/\s+/g,'').length;
    const isQuestion = /[?？]$/.test(t) || /(왜|어떻게|뭐지|뭐야|무슨|대체)/.test(t);
    const hasNumber = /\d/.test(t);
    const hasEmo = EMO_WORDS.some(w => t.includes(w));
    const hasContrast = CONTRAST_WORDS.some(w => t.includes(w));
    const hasQuote = /“|”|\"|‘|’|\'/.test(t);

    return { len, isQuestion, hasNumber, hasEmo, hasContrast, hasQuote };
  }

  function scoreTitleProfile(title, profile) {
    const s = titleSignals(title);
    let score = 0;
    // length preference
    const L = s.len;
    if (profile.shortsRules.titleLen==="short") score += (L<=16 ? 2 : L<=24 ? 1 : 0);
    if (profile.shortsRules.titleLen==="normal") score += (L<=26 ? 2 : L<=34 ? 1 : 0);
    if (profile.shortsRules.titleLen==="long") score += (L>=22 ? 1 : 0);

    if (profile.shortsRules.preferQuestion && s.isQuestion) score += 2;
    if (profile.shortsRules.preferNumbers && s.hasNumber) score += 1;
    if (profile.shortsRules.preferEmotion && s.hasEmo) score += 1;
    if (profile.shortsRules.preferContrast && s.hasContrast) score += 1;
    if (s.hasQuote) score += 0.5;

    return { score, signals: s };
  }

  function scoreTitleAuto(title, learned) {
    // learned: { preferQuestion, preferContrast, preferNumbers, preferEmotion, idealLenRange:[a,b] }
    const s = titleSignals(title);
    let score = 0;
    if (learned.preferQuestion && s.isQuestion) score += 2;
    if (learned.preferContrast && s.hasContrast) score += 1;
    if (learned.preferNumbers && s.hasNumber) score += 1;
    if (learned.preferEmotion && s.hasEmo) score += 1;
    const [a,b] = learned.idealLenRange || [12,28];
    if (s.len>=a && s.len<=b) score += 2;
    return { score, signals: s };
  }

  function detectForbidden(title, desc, forbiddenList) {
    const txt = (title||"") + " " + (desc||"");
    const hits = [];
    for (const k of (forbiddenList||[])) {
      if (!k) continue;
      if (txt.includes(k)) hits.push(k);
    }
    return hits;
  }

  function buildKeywordStats(videos) {
    const counts = new Map();
    for (const v of videos) {
      const toks = tokenize((v.title||"") + " " + (v.description||""));
      for (const w of toks) counts.set(w, (counts.get(w)||0)+1);
    }
    const arr = [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0, 50);
    return arr;
  }

  function topKeywords(videos, k=20) {
    return buildKeywordStats(videos).slice(0,k).map(([w,c])=>({ keyword:w, count:c }));
  }

  function bucketByAge(v) {
    const a = ageDays(v.publishedAt);
    if (a==null) return "unknown";
    if (a <= 7) return "0-7d";
    if (a <= 30) return "8-30d";
    if (a <= 90) return "31-90d";
    return "90d+";
  }

  function computeVideoRow(v, categoriesMap, profile, learnedAuto) {
    const views = v.views ?? 0;
    const likes = v.likes ?? null;
    const comments = v.comments ?? null;
    const a = ageDays(v.publishedAt) ?? null;
    const vpd = (a!=null && a>0) ? (views/a) : (a===0 ? views : null);

    const likeRate = (likes!=null && views>0) ? (likes/views*100) : null;
    const commentRate = (comments!=null && views>0) ? (comments/views*100) : null;

    const hashtags = v.hashtags || [];
    const tags = v.tags || null;

    const forbidHits = detectForbidden(v.title, v.description, profile.forbidden);
    const titleScoreProfile = scoreTitleProfile(v.title, profile);
    const titleScoreAuto = learnedAuto ? scoreTitleAuto(v.title, learnedAuto) : { score: null, signals: titleSignals(v.title) };

    return {
      videoId: v.videoId,
      title: v.title,
      url: "https://www.youtube.com/watch?v=" + v.videoId,
      views,
      vpd,
      likes,
      likeRate,
      comments,
      commentRate,
      categoryId: v.categoryId,
      category: categoriesMap?.[v.categoryId] || (v.categoryId || "미제공"),
      publishedAt: v.publishedAt,
      hashtags,
      tags,
      durationSeconds: v.durationSeconds,
      isShorts: v.isShorts,
      ageDays: a,
      forbidHits,
      titleSignals: titleScoreProfile.signals,
      titleScoreProfile: titleScoreProfile.score,
      titleScoreAuto: titleScoreAuto.score,
      _raw: v
    };
  }

  function learnAutoPrefs(rows) {
    // 아주 단순: 상위 30% vs 하위 30%의 제목 신호 차이로 선호를 추정
    const sorted = rows.slice().sort((a,b)=>(b.vpd||0)-(a.vpd||0));
    if (sorted.length < 10) return {
      preferQuestion:true, preferContrast:true, preferNumbers:true, preferEmotion:true, idealLenRange:[12,28]
    };

    const topN = Math.max(5, Math.floor(sorted.length*0.3));
    const botN = Math.max(5, Math.floor(sorted.length*0.3));
    const top = sorted.slice(0, topN);
    const bot = sorted.slice(sorted.length-botN);

    function rate(list, key) {
      const hits = list.filter(r => r.titleSignals?.[key]).length;
      return hits / Math.max(1, list.length);
    }

    const tq = rate(top,"isQuestion") - rate(bot,"isQuestion");
    const tc = rate(top,"hasContrast") - rate(bot,"hasContrast");
    const tn = rate(top,"hasNumber") - rate(bot,"hasNumber");
    const te = rate(top,"hasEmo") - rate(bot,"hasEmo");

    const lensTop = top.map(r=>r.titleSignals?.len).filter(Boolean);
    const m = median(lensTop) ?? 20;
    const a = clamp(Math.round(m-8), 8, 40);
    const b = clamp(Math.round(m+8), 12, 60);

    return {
      preferQuestion: tq > 0.05,
      preferContrast: tc > 0.05,
      preferNumbers: tn > 0.05,
      preferEmotion: te > 0.05,
      idealLenRange: [a,b]
    };
  }

  // ========= Report builder =========
  function buildReport(bundle) {
    const profile = getActiveProfile();
    const filtered = applyFilters(bundle.videos);

    // prepare rows
    const rows0 = filtered.map(v => computeVideoRow(v, bundle.categoriesMap, profile, null));
    const learned = learnAutoPrefs(rows0);

    const rows = filtered.map(v => computeVideoRow(v, bundle.categoriesMap, profile, learned));

    // score = age-adjusted performance ratio vs bucket median vpd
    const byBucket = new Map();
    for (const r of rows) {
      const b = bucketByAge(r);
      if (!byBucket.has(b)) byBucket.set(b, []);
      byBucket.get(b).push(r.vpd);
    }
    const medByBucket = {};
    for (const [b, arr] of byBucket.entries()) medByBucket[b] = median(arr) || 0;

    for (const r of rows) {
      const b = bucketByAge(r);
      const base = medByBucket[b] || 0;
      r.score = base>0 && r.vpd!=null ? (r.vpd/base) : (r.vpd ?? 0);
      r.bucket = b;
    }

    // top / under (10 each)
    const sortedByScore = rows.slice().sort((a,b)=>(b.score||-Infinity)-(a.score||-Infinity));
    const top10 = sortedByScore.slice(0, 10);
    const under10 = sortedByScore.slice(-10).reverse(); // bottom -> for display

    // topic keywords
    const kw20 = topKeywords(filtered, 20);

    // patterns
    const avgQ = average(rows.filter(r=>r.titleSignals.isQuestion).map(r=>r.vpd));
    const avgNQ = average(rows.filter(r=>!r.titleSignals.isQuestion).map(r=>r.vpd));
    const avgContrast = average(rows.filter(r=>r.titleSignals.hasContrast).map(r=>r.vpd));
    const avgNoContrast = average(rows.filter(r=>!r.titleSignals.hasContrast).map(r=>r.vpd));

    const schedule = buildScheduleStats(rows);

    // kpis
    const viewsArr = rows.map(r=>r.views);
    const vpdArr = rows.map(r=>r.vpd);
    const likeRateArr = rows.map(r=>r.likeRate);
    const commentRateArr = rows.map(r=>r.commentRate);

    const kpis = {
      count: rows.length,
      shortsRatio: computeShortsRatio(bundle.videos),
      medianViews: median(viewsArr),
      p25Views: pct(viewsArr, 0.25),
      p75Views: pct(viewsArr, 0.75),
      medianVPD: median(vpdArr),
      medianLikeRate: median(likeRateArr),
      medianCommentRate: median(commentRateArr),
      uploadFreqPerWeek: estimateUploadFreq(bundle.videos),
    };

    // good/bad (simple)
    const good = [];
    const bad = [];
    if ((kpis.medianVPD||0) > 1000) good.push("최근 영상들의 <b>조회수/일 중앙값</b>이 준수합니다");
    if ((kpis.medianLikeRate||0) > 2) good.push("좋아요율 중앙값이 괜찮은 편(콘텐츠 만족 신호)");
    if (schedule.bestHour != null) good.push(`특정 업로드 시간대(${schedule.bestHour}시)에서 성과가 더 좋은 경향`);
    if ((kpis.shortsRatio||0) < 0.2 && $("selContentType").value==="shorts") bad.push("쇼츠 비중이 낮아 쇼츠 기준 샘플이 부족할 수 있습니다");
    if (rows.length < 15) bad.push("분석 표본이 적어(15개 미만) 패턴 신뢰도가 낮습니다");
    if ((kpis.medianLikeRate||0) < 1) bad.push("좋아요율이 낮은 편 → 훅/전개/타겟 미스매치 가능");
    if (schedule.weakDay != null) bad.push(`특정 요일(${schedule.weakDay}) 업로드 성과가 약한 경향`);

    return {
      channel: summarizeChannel(bundle.channel),
      kpis,
      rows,
      top10,
      under10,
      keywords20: kw20,
      patterns: {
        questionVs: { question: avgQ, nonQuestion: avgNQ },
        contrastVs: { contrast: avgContrast, nonContrast: avgNoContrast },
        schedule
      },
      learnedAuto: learned,
      goodBad: { good, bad },
      meta: {
        appliedFilters: getCurrentFiltersSnapshot(),
        criteria: state.criteria,
        profile: profile
      }
    };
  }

  function average(arr) {
    const a = arr.filter(v=>v!=null && isFinite(v));
    if (!a.length) return null;
    return a.reduce((s,x)=>s+x,0)/a.length;
  }

  function computeShortsRatio(videos) {
    const rule = $("selShortsRule").value;
    const threshold = Number($("selShortsThreshold").value);
    let shorts=0, total=0;
    for (const v of videos) {
      total++;
      if (classifyIsShorts(v, rule, threshold)) shorts++;
    }
    return total? shorts/total : null;
  }

  function estimateUploadFreq(videos) {
    // in last 30 days: count / 4.285
    const cutoff = Date.now() - 30*24*3600*1000;
    const recent = videos.filter(v=>new Date(v.publishedAt).getTime() >= cutoff);
    return recent.length / 4.285;
  }

  function buildScheduleStats(rows) {
    // avg vpd by weekday and hour
    const byHour = Array.from({length:24}, ()=>[]);
    const byDay = Array.from({length:7}, ()=>[]); // 0=Sun
    for (const r of rows) {
      const d = new Date(r.publishedAt);
      if (!isFinite(d.getTime())) continue;
      const h = d.getHours();
      const wd = d.getDay();
      if (r.vpd!=null) {
        byHour[h].push(r.vpd);
        byDay[wd].push(r.vpd);
      }
    }
    const avgHour = byHour.map(a=>average(a)??null);
    const avgDay = byDay.map(a=>average(a)??null);

    const bestHour = argmax(avgHour);
    const weakHour = argmin(avgHour);
    const bestDayIdx = argmax(avgDay);
    const weakDayIdx = argmin(avgDay);

    const dayName = ["일","월","화","수","목","금","토"];
    return {
      bestHour,
      weakHour,
      bestDay: bestDayIdx!=null ? dayName[bestDayIdx] : null,
      weakDay: weakDayIdx!=null ? dayName[weakDayIdx] : null,
      avgHour,
      avgDay,
      dayName
    };
  }

  function argmax(arr) {
    let best = null, bestV = -Infinity;
    for (let i=0;i<arr.length;i++) {
      const v = arr[i];
      if (v==null) continue;
      if (v>bestV) bestV=v, best=i;
    }
    return best;
  }
  function argmin(arr) {
    let best = null, bestV = Infinity;
    for (let i=0;i<arr.length;i++) {
      const v = arr[i];
      if (v==null) continue;
      if (v<bestV) bestV=v, best=i;
    }
    return best;
  }

  function summarizeChannel(ch) {
    const sn = ch?.snippet || {};
    const st = ch?.statistics || {};
    return {
      channelId: ch?.id,
      title: sn?.title,
      description: sn?.description || "",
      publishedAt: sn?.publishedAt,
      country: sn?.country || null,
      subscribers: st?.subscriberCount ? Number(st.subscriberCount) : null,
      views: st?.viewCount ? Number(st.viewCount) : null,
      videoCount: st?.videoCount ? Number(st.videoCount) : null,
      thumbnails: sn?.thumbnails || null
    };
  }

  function getCurrentFiltersSnapshot() {
    return {
      contentType: $("selContentType").value,
      shortsRule: $("selShortsRule").value,
      shortsThreshold: Number($("selShortsThreshold").value),
      period: $("selPeriod").value,
      recentN: Number($("selN").value),
      minViews: $("inputMinViews").value ? Number($("inputMinViews").value) : null,
      maxViews: $("inputMaxViews").value ? Number($("inputMaxViews").value) : null,
      quotaOptions: {
        onlyN: $("optOnlyN").checked,
        minDetails: $("optMinDetails").checked,
        forceCache: $("optForceCache").checked
      }
    };
  }

  // ========= Underperform Diagnosis =========
  function buildUnderDiagnoses(report) {
    const prof = getActiveProfile();
    const learned = report.learnedAuto;

    // keyword set for relevance
    const kwSet = new Set(report.keywords20.map(x=>x.keyword));
    const dayName = ["일","월","화","수","목","금","토"];
    const sch = report.patterns.schedule;

    return report.under10.map(r => {
      const reasonsProfile = [];
      const reasonsAuto = [];
      const fixes = { titles: [], hashtags: [], sequel: [] };

      // 1) title hook heuristic
      const tSig = r.titleSignals;
      if (tSig.len > 40) {
        reasonsProfile.push("제목이 길어 훅이 약해질 수 있음(가독성 저하)");
        reasonsAuto.push("제목 길이가 상위 성과 구간(학습)보다 길 수 있음");
      }
      if (!tSig.isQuestion && prof.shortsRules.preferQuestion) reasonsProfile.push("의문형 훅 선호 프로필인데 의문형 신호가 약함");
      if (!tSig.hasContrast && prof.shortsRules.preferContrast) reasonsProfile.push("대비/반전 구조 선호 프로필인데 대비 신호가 약함");
      if (!tSig.hasEmo && prof.shortsRules.preferEmotion) reasonsProfile.push("감정 단어 선호 프로필인데 감정 신호가 약함");
      if (state.criteria==="auto") {
        if (!tSig.isQuestion && learned.preferQuestion) reasonsAuto.push("상위 영상에서 의문형 비중이 더 높은데 해당 영상은 비의문형");
        if (!tSig.hasContrast && learned.preferContrast) reasonsAuto.push("상위 영상에서 대비/반전 신호가 더 높은데 해당 영상은 약함");
      }

      // 2) hashtags
      const h = r.hashtags || [];
      if (h.length === 0) reasonsProfile.push("해시태그가 없어서 탐색성(추천/검색) 보조 신호가 약함(가능 범위)");
      if (h.length >= 12) reasonsProfile.push("해시태그가 과다해 핵심 신호가 희석될 수 있음");
      // relevance check
      const rel = h.filter(x => kwSet.has(x.replace('#','').toLowerCase()));
      if (h.length>0 && rel.length===0) reasonsProfile.push("해시태그가 현재 채널 상위 토픽 키워드와 연결이 약함(무관/분산 가능)");

      // 3) upload schedule
      const d = new Date(r.publishedAt);
      const wd = dayName[d.getDay()];
      const hh = d.getHours();
      if (sch.bestHour!=null && sch.weakHour!=null && hh===sch.weakHour) reasonsProfile.push(`업로드 시간대가 채널 내 약한 구간(${hh}시)에 가까움`);
      if (sch.weakDay && wd===sch.weakDay) reasonsProfile.push(`업로드 요일이 채널 내 약한 구간(${wd})에 가까움`);

      // 4) category / length mismatch
      if (r.isShorts && r.durationSeconds!=null) {
        const thr = Number($("selShortsThreshold").value);
        if (r.durationSeconds > thr) reasonsProfile.push(`쇼츠로 분류되지만 길이(${r.durationSeconds}s)가 임계값(${thr}s)을 초과할 수 있음(룰/포맷 미스매치)`);
      }

      // 5) forbidden keywords
      if (r.forbidHits?.length) reasonsProfile.push(`프로필 경고 키워드 감지: ${r.forbidHits.join(", ")} (감점/경고)`);

      // ---- Fix proposals (3개 필수) ----
      // 1) title 개선 3개 (프로필 훅 선호 기반)
      const baseKws = pickKeywordsFromTitle(r.title, report.keywords20);
      fixes.titles = proposeTitles(r.title, baseKws, prof.shortsRules.hookPref);

      // 2) hashtags 정리안
      fixes.hashtags = proposeHashtags(report.keywords20, h, prof);

      // 3) 다음 편(후속 콘텐츠)
      fixes.sequel = proposeSequels(baseKws, prof);

      return {
        ...r,
        reasons: {
          profile: reasonsProfile,
          auto: reasonsAuto
        },
        fixes
      };
    });
  }

  function pickKeywordsFromTitle(title, kw20) {
    const t = (title||"").toLowerCase();
    const hits = [];
    for (const k of kw20.map(x=>x.keyword)) {
      if (t.includes(k)) hits.push(k);
      if (hits.length>=3) break;
    }
    if (!hits.length) {
      const toks = tokenize(title).slice(0,3);
      return toks.length ? toks : ["상황","반전","한마디"];
    }
    return hits;
  }

  function proposeTitles(original, kws, hookPref) {
    const k1 = kws[0] || "이거";
    const k2 = kws[1] || "한마디";
    const k3 = kws[2] || "결말";
    const out = [];

    if (hookPref==="question") {
      out.push(`${k1} 왜 이렇게 되는 거야?`);
      out.push(`${k2} 한 번에 분위기 바뀐 이유`);
      out.push(`이 상황에서 ${k3}는 맞는 걸까?`);
    } else if (hookPref==="twist") {
      out.push(`${k1}인 줄 알았는데… 결말이 반전`);
      out.push(`다들 ${k2}라고 생각하는데, 진짜는 이거`);
      out.push(`웃긴데 무서운 ${k3} 포인트`);
    } else if (hookPref==="dialog") {
      out.push(`상대가 한 말: “${k2}”`);
      out.push(`내가 ${k1}라고 했더니 돌아온 말`);
      out.push(`대화 10초 만에 ${k3}난 썰`);
    } else {
      // situation
      out.push(`${k1} 때문에 분위기 터진 날`);
      out.push(`평범한데 이상하게 ${k2}만 기억남`);
      out.push(`이게 ${k3}까지 가는 과정`);
    }

    // 원제목이 너무 좋으면 변형도 추가
    if (original && original.length <= 26) out.unshift(`${original} (제목 유지 + 훅 강화 버전)`);
    return out.slice(0,3);
  }

  function proposeHashtags(kw20, current, prof) {
    // 목표 6~9개: 핵심 3 + 장르 2 + 타깃 1 + 포맷 1 + 여유 1
    const core = kw20.slice(0,8).map(x=>"#"+x.keyword).slice(0,4);

    // genre from weights
    const topGenres = Object.entries(prof.weights||{})
      .sort((a,b)=>b[1]-a[1])
      .slice(0,3)
      .map(([k])=>"#"+k);

    const format = ["#shorts","#쇼츠"];
    const pick = [];

    for (const x of core) if (!pick.includes(x)) pick.push(x);
    for (const x of topGenres) if (!pick.includes(x)) pick.push(x);
    for (const x of format) if (!pick.includes(x)) pick.push(x);

    // 현재 해시태그 중 1~2개만 유지(길이 과다 방지)
    const keep = (current||[]).slice(0,2);
    for (const x of keep) if (!pick.includes(x)) pick.push(x);

    return pick.slice(0,9);
  }

  function proposeSequels(kws, prof) {
    const k1 = kws[0] || "상황";
    const k2 = kws[1] || "한마디";
    return [
      `같은 ${k1}에서 “다른 선택”을 했으면 결과가 바뀌었을까? (비교형 후속편)`,
      `${k2} 이후 상대 반응 3단계(텍스트/표정/행동)로 확장해서 2편 구성`,
      `댓글에서 가장 많이 나올 ‘갈리는 포인트’ 1개를 먼저 던지고 썰로 회수`
    ];
  }

  // ========= GPT Pack / Prompt =========
  function buildGptPack(kind) {
    // kind: report|titles|plan|benchRules|compare
    const prof = getActiveProfile();
    const pack = {
      generatedAt: new Date().toISOString(),
      mode: state.mode,
      criteria: state.criteria,
      profile: prof,
      filters: getCurrentFiltersSnapshot(),
      data: {},
    };

    if (state.mode==="mine") {
      pack.data.mine = packFromReport(state.report.mine);
    } else if (state.mode==="bench") {
      pack.data.bench = packFromReport(state.report.bench);
    } else {
      pack.data.mine = packFromReport(state.report.mine);
      pack.data.bench = packFromReport(state.report.bench);
      pack.data.compare = state.report.compare || null;
    }
    return pack;
  }

  function packFromReport(r) {
    if (!r) return null;
    return {
      channel: r.channel,
      summaryKPIs: r.kpis,
      top10: r.top10.map(x=>pickVideoPack(x)),
      under10: buildUnderDiagnoses(r).map(x=>({
        ...pickVideoPack(x),
        reasons: x.reasons,
        fixes: x.fixes
      })),
      topicKeywords20: r.keywords20,
      observedPatterns: {
        questionAvgVPD: r.patterns.questionVs.question,
        nonQuestionAvgVPD: r.patterns.questionVs.nonQuestion,
        contrastAvgVPD: r.patterns.contrastVs.contrast,
        nonContrastAvgVPD: r.patterns.contrastVs.nonContrast,
        schedule: r.patterns.schedule
      },
      autoLearned: r.learnedAuto
    };
  }

  function pickVideoPack(x) {
    return {
      videoId: x.videoId,
      title: x.title,
      url: x.url,
      publishedAt: x.publishedAt,
      views: x.views,
      viewsPerDay: x.vpd,
      likeRate: x.likeRate,
      commentRate: x.commentRate,
      category: x.category,
      hashtags: x.hashtags,
      tags: x.tags,
      durationSeconds: x.durationSeconds,
      isShorts: x.isShorts,
      score: x.score,
      bucket: x.bucket
    };
  }

  function buildGptPrompt(type) {
    const includeJson = state.jsonOut;
    const base = [
`너는 “유튜브 쇼츠 성장 분석가 + 시니어 풀스택 엔지니어 + UX/UI 디자이너”다`,
`내가 붙여넣는 ‘분석팩(JSON 또는 구조화 텍스트)’만 근거로 답해라`,
`추정은 가능하지만 반드시 “추정”이라고 표시하고, 근거 필드(videoId/title/viewsPerDay 등)를 함께 적어라`,
`출력은 복사하기 쉬운 Markdown으로 작성하라`,
    ];

    let task = "";
    if (type==="report") {
      task = [
        `(1) 한 페이지 요약 리포트(현재 상태/좋은 점/나쁜 점/핵심 문제 3개/우선순위)`,
        `(2) Underperform 영상 각각에 대해: 원인(근거) + 개선안(제목 3개/해시태그 정리/후속편 구성)`,
        `(3) 제목 템플릿 10개(채널 콘셉트 프로필 반영)`,
        `(4) 다음 30일 콘텐츠 플랜(주차별 7~10개: 주제/훅/전개/근거/난이도/주의사항)`,
      ].join("\n");
    } else if (type==="titles") {
      task = [
        `(1) 상위 토픽 키워드 기반 “제목+훅” 30개(의문형/반전형/대사형/상황요약형 각 7~8개)`,
        `(2) Underperform의 기존 제목을 개선한 버전(각 3개)`,
        `(3) 해시태그 세트 10개(6~9개 구성, 과다/무관 회피)`,
      ].join("\n");
    } else if (type==="plan") {
      task = [
        `(1) 30일 플랜(날짜 대신 Day1~Day30): 주제/훅 1문장/전개 3비트/오프닝 대사/추천 해시태그`,
        `(2) 플랜에 “벤치마킹 규칙”을 반영한 이유를 각 주차마다 3줄로 설명`,
      ].join("\n");
    } else if (type==="benchRules") {
      task = [
        `(1) 벤치 채널의 성공 규칙 10개(제목/포맷/업로드 타이밍/해시태그/토픽 클러스터)`,
        `(2) 내 채널에 이식 가능한 규칙 5개 + 바로 적용 예시(제목/기획)`,
        `(3) 위험 요소 3개(내 채널 콘셉트와 충돌 가능성 포함)`,
      ].join("\n");
    } else {
      task = [
        `(1) 내 채널 vs 벤치 채널 핵심 KPI 차이(표로)`,
        `(2) 상위 토픽/훅 패턴 차이`,
        `(3) 내 채널이 바로 따라 할 “우선순위 TOP7 액션”`,
        `(4) 내 채널 Underperform을 벤치 규칙으로 개선하는 리라이트(각 3개)`,
      ].join("\n");
    }

    const jsonInstr = includeJson
      ? `\n추가로, 위 Markdown 결과를 그대로 구조화한 JSON도 마지막에 함께 출력하라(키는 영어, 값은 한국어 가능).`
      : "";

    return `${base.join("\n")}\n\n[해야 할 일]\n${task}\n${jsonInstr}\n\n[입력: 분석팩]\n(여기에 내가 붙여넣은 분석팩을 근거로만 답해라)`;
  }

  // ========= Rendering =========
  function renderKPIs(r) {
    const g = $("kpiGrid");
    g.innerHTML = "";
    if (!r) return;

    const items = [
      ["분석 표본", r.kpis.count!=null ? fmt.format(r.kpis.count) : "—"],
      ["업로드 빈도/주(추정)", r.kpis.uploadFreqPerWeek!=null ? r.kpis.uploadFreqPerWeek.toFixed(1) : "—"],
      ["쇼츠 비율(추정)", r.kpis.shortsRatio!=null ? Math.round(r.kpis.shortsRatio*100)+"%" : "—"],
      ["조회수 중앙값", r.kpis.medianViews!=null ? fmt.format(Math.round(r.kpis.medianViews)) : "—"],
      ["조회수 P25", r.kpis.p25Views!=null ? fmt.format(Math.round(r.kpis.p25Views)) : "—"],
      ["조회수 P75", r.kpis.p75Views!=null ? fmt.format(Math.round(r.kpis.p75Views)) : "—"],
      ["조회수/일 중앙값", r.kpis.medianVPD!=null ? fmt.format(Math.round(r.kpis.medianVPD)) : "—"],
      ["좋아요율 중앙값", r.kpis.medianLikeRate!=null ? r.kpis.medianLikeRate.toFixed(2)+"%" : "미제공/불가"],
      ["댓글율 중앙값", r.kpis.medianCommentRate!=null ? r.kpis.medianCommentRate.toFixed(2)+"%" : "미제공/불가"],
    ];

    for (const [k,v] of items) {
      const card = document.createElement("div");
      card.className = "p-3 rounded-xl bg-slate-950 border border-slate-800";
      card.innerHTML = `<div class="text-xs text-slate-400">${escapeHtml(k)}</div><div class="text-lg font-semibold">${escapeHtml(v)}</div>`;
      g.appendChild(card);
    }
  }

  function renderGoodBad(r) {
    if (!r) return;
    const good = r.goodBad.good.length ? ("<b>좋은 점</b><br/>- " + r.goodBad.good.join("<br/>- ")) : "<b>좋은 점</b><br/>- (표본 부족/신호 약함)";
    const bad  = r.goodBad.bad.length ? ("<br/><br/><b>나쁜 점</b><br/>- " + r.goodBad.bad.join("<br/>- ")) : "<br/><br/><b>나쁜 점</b><br/>- (명확한 약점 신호가 적음)";
    $("goodBad").innerHTML = good + bad;
  }

  function renderPatterns(r) {
    if (!r) return;
    const p = r.patterns;
    const sch = p.schedule;
    $("patterns").innerHTML = `
      - 의문형 제목 평균 조회수/일: <b>${p.questionVs.question!=null ? fmt.format(Math.round(p.questionVs.question)) : "—"}</b> / 비의문형: <b>${p.questionVs.nonQuestion!=null ? fmt.format(Math.round(p.questionVs.nonQuestion)) : "—"}</b><br/>
      - 대비/반전 신호 평균 조회수/일: <b>${p.contrastVs.contrast!=null ? fmt.format(Math.round(p.contrastVs.contrast)) : "—"}</b> / 없음: <b>${p.contrastVs.nonContrast!=null ? fmt.format(Math.round(p.contrastVs.nonContrast)) : "—"}</b><br/>
      - 업로드 강한 시간대(추정): <b>${sch.bestHour!=null ? sch.bestHour+"시" : "—"}</b> / 약한 시간대: <b>${sch.weakHour!=null ? sch.weakHour+"시" : "—"}</b><br/>
      - 업로드 강한 요일(추정): <b>${sch.bestDay ?? "—"}</b> / 약한 요일: <b>${sch.weakDay ?? "—"}</b>
    `;
  }

  const TOP_COLS = [
    { key:"title", label:"제목", sortable:true, w:"w-[340px]" },
    { key:"views", label:"조회수", sortable:true },
    { key:"vpd", label:"조회수/일", sortable:true },
    { key:"likeRate", label:"좋아요율", sortable:true },
    { key:"commentRate", label:"댓글율", sortable:true },
    { key:"category", label:"카테고리", sortable:true },
    { key:"publishedAt", label:"업로드일", sortable:true },
    { key:"url", label:"링크", sortable:false },
    { key:"hashtags", label:"해시태그(설명)", sortable:false, w:"w-[360px]" },
    { key:"tags", label:"태그(tags)", sortable:false, w:"w-[280px]" },
  ];

  function renderTopTable(r) {
    const head = $("topHead");
    const body = $("topBody");
    head.innerHTML = "";
    body.innerHTML = "";
    if (!r) return;

    for (const c of TOP_COLS) {
      const th = document.createElement("th");
      th.className = `px-3 py-2 text-left text-xs uppercase tracking-wide ${c.w||""} ${c.sortable ? "cursor-pointer hover:bg-slate-800/60" : ""}`;
      th.textContent = c.label;
      if (c.sortable) {
        th.onclick = () => {
          if (state.tables.top.sortKey === c.key) {
            state.tables.top.sortDir = state.tables.top.sortDir==="asc" ? "desc" : "asc";
          } else {
            state.tables.top.sortKey = c.key;
            state.tables.top.sortDir = "desc";
          }
          state.tables.top.page = 1;
          renderTopTable(r);
        };
      }
      head.appendChild(th);
    }

    const q = state.tables.top.query.toLowerCase();
    let rows = r.rows.slice();

    if (q) {
      rows = rows.filter(x =>
        (x.title||"").toLowerCase().includes(q) ||
        (x.hashtags||[]).join(" ").toLowerCase().includes(q)
      );
    }

    const k = state.tables.top.sortKey;
    const dir = state.tables.top.sortDir;
    rows.sort((a,b)=>{
      const va = a[k], vb = b[k];
      const na = (va==null) ? -Infinity : (typeof va==="string" ? va : Number(va));
      const nb = (vb==null) ? -Infinity : (typeof vb==="string" ? vb : Number(vb));
      if (typeof va==="string" || typeof vb==="string") {
        return dir==="asc" ? String(va||"").localeCompare(String(vb||""),'ko') : String(vb||"").localeCompare(String(va||""),'ko');
      }
      return dir==="asc" ? (na-nb) : (nb-na);
    });

    const pageSize = state.tables.top.pageSize;
    const page = state.tables.top.page;
    const total = rows.length;
    const maxPage = Math.max(1, Math.ceil(total/pageSize));
    state.tables.top.page = clamp(page, 1, maxPage);

    const start = (state.tables.top.page-1)*pageSize;
    const chunk = rows.slice(start, start+pageSize);

    for (const x of chunk) {
      const tr = document.createElement("tr");
      tr.className = "border-t border-slate-900 hover:bg-slate-900/60";
      tr.innerHTML = `
        <td class="px-3 py-2 wrap-anywhere">
          <div class="font-semibold">${escapeHtml(x.title)}</div>
          <div class="text-xs text-slate-500">score: ${x.score!=null ? x.score.toFixed(2) : "—"} · bucket: ${escapeHtml(x.bucket||"—")}</div>
        </td>
        <td class="px-3 py-2">${fmt.format(x.views||0)}</td>
        <td class="px-3 py-2">${x.vpd!=null ? fmt.format(Math.round(x.vpd)) : "—"}</td>
        <td class="px-3 py-2">${x.likeRate!=null ? x.likeRate.toFixed(2)+"%" : "미제공"}</td>
        <td class="px-3 py-2">${x.commentRate!=null ? x.commentRate.toFixed(2)+"%" : "미제공"}</td>
        <td class="px-3 py-2">${escapeHtml(x.category||"미제공")}</td>
        <td class="px-3 py-2">${escapeHtml((x.publishedAt||"").slice(0,10))}</td>
        <td class="px-3 py-2"><a class="text-indigo-300 hover:underline" href="${x.url}" target="_blank" rel="noreferrer">열기</a></td>
        <td class="px-3 py-2 wrap-anywhere">${renderExpandableList(x.hashtags)}</td>
        <td class="px-3 py-2 wrap-anywhere">${renderExpandableList(x.tags)}</td>
      `;
      body.appendChild(tr);
    }

    $("topPagerInfo").textContent = `총 ${fmt.format(total)}개 · ${state.tables.top.page}/${maxPage} 페이지`;
    $("topPrev").onclick = () => { state.tables.top.page = Math.max(1, state.tables.top.page-1); renderTopTable(r); };
    $("topNext").onclick = () => { state.tables.top.page = Math.min(maxPage, state.tables.top.page+1); renderTopTable(r); };
  }

  function renderExpandableList(listOrNull) {
    if (!listOrNull) return `<span class="text-slate-500">미제공</span>`;
    const arr = Array.isArray(listOrNull) ? listOrNull : String(listOrNull).split(/[;,]/).map(s=>s.trim()).filter(Boolean);
    if (!arr.length) return `<span class="text-slate-500">없음</span>`;
    const short = arr.slice(0, 6).join(" ");
    const full = arr.join(" ");
    if (arr.length <= 6 && full.length <= 60) return escapeHtml(full);
    const id = "ex_" + Math.random().toString(36).slice(2,8);
    return `
      <div>
        <div id="${id}_short" class="text-slate-200">${escapeHtml(short)}…</div>
        <button class="text-xs text-indigo-300 hover:underline mt-1" onclick="document.getElementById('${id}_short').textContent='${escapeHtml(full).replace(/'/g,"\\'")}'">더보기</button>
      </div>
    `;
  }

  function renderUnderList(r) {
    const wrap = $("underList");
    wrap.innerHTML = "";
    if (!r) return;

    const list = buildUnderDiagnoses(r);
    const q = state.tables.under.query.toLowerCase();
    let filtered = list;
    if (q) {
      filtered = list.filter(x =>
        (x.title||"").toLowerCase().includes(q) ||
        (x.reasons.profile||[]).join(" ").toLowerCase().includes(q) ||
        (x.reasons.auto||[]).join(" ").toLowerCase().includes(q)
      );
    }

    const pageSize = state.tables.under.pageSize;
    const page = state.tables.under.page;
    const total = filtered.length;
    const maxPage = Math.max(1, Math.ceil(total/pageSize));
    state.tables.under.page = clamp(page, 1, maxPage);

    const start = (state.tables.under.page-1)*pageSize;
    const chunk = filtered.slice(start, start+pageSize);

    for (const x of chunk) {
      const card = document.createElement("div");
      card.className = "p-4 rounded-2xl bg-slate-950 border border-slate-800";
      const dt = new Date(x.publishedAt);
      const wd = ["일","월","화","수","목","금","토"][dt.getDay()];
      const hh = dt.getHours();

      const reasons = (state.criteria==="profile") ? x.reasons.profile : (x.reasons.auto.length ? x.reasons.auto : x.reasons.profile);
      const otherReasons = (state.criteria==="profile") ? x.reasons.auto : x.reasons.profile;

      card.innerHTML = `
        <div class="flex flex-col lg:flex-row lg:items-start lg:justify-between gap-3">
          <div class="flex-1">
            <div class="text-sm text-slate-400">score ${x.score!=null ? x.score.toFixed(2) : "—"} · bucket ${escapeHtml(x.bucket||"—")} · ${wd} ${hh}시 업로드</div>
            <div class="text-lg font-semibold mt-1 wrap-anywhere">${escapeHtml(x.title)}</div>
            <div class="text-sm text-slate-300 mt-2 flex flex-wrap gap-3">
              <span>조회수: <b>${fmt.format(x.views||0)}</b></span>
              <span>조회수/일: <b>${x.vpd!=null ? fmt.format(Math.round(x.vpd)) : "—"}</b></span>
              <span>좋아요율: <b>${x.likeRate!=null ? x.likeRate.toFixed(2)+"%" : "미제공"}</b></span>
              <span>댓글율: <b>${x.commentRate!=null ? x.commentRate.toFixed(2)+"%" : "미제공"}</b></span>
              <span>카테고리: <b>${escapeHtml(x.category||"미제공")}</b></span>
            </div>
            <div class="mt-2">
              <a class="text-indigo-300 hover:underline" href="${x.url}" target="_blank" rel="noreferrer">영상 열기</a>
            </div>

            <div class="mt-3 grid grid-cols-1 lg:grid-cols-2 gap-3">
              <div class="p-3 rounded-xl bg-slate-900 border border-slate-800">
                <div class="text-sm font-semibold">원인 추정(근거) · ${state.criteria==="profile" ? "Profile" : "Auto 우선"}</div>
                <ul class="mt-2 text-sm text-slate-200 list-disc pl-5 space-y-1">
                  ${reasons.length ? reasons.map(r=>`<li>${escapeHtml(r)}</li>`).join("") : "<li>명확한 단일 원인이 아니라 복합 요인일 수 있음(표본/노이즈)</li>"}
                </ul>
              </div>
              <div class="p-3 rounded-xl bg-slate-900 border border-slate-800">
                <div class="text-sm font-semibold">다른 기준에서의 신호 · ${state.criteria==="profile" ? "Auto" : "Profile"}</div>
                <ul class="mt-2 text-sm text-slate-200 list-disc pl-5 space-y-1">
                  ${otherReasons.length ? otherReasons.map(r=>`<li>${escapeHtml(r)}</li>`).join("") : "<li>보조 신호가 약하거나 동일 결론</li>"}
                </ul>
              </div>
            </div>

            <div class="mt-3 p-3 rounded-xl bg-slate-900 border border-slate-800">
              <div class="text-sm font-semibold">개선 제안(필수 3종)</div>
              <div class="mt-2 grid grid-cols-1 lg:grid-cols-3 gap-3">
                <div class="p-3 rounded-xl bg-slate-950 border border-slate-800">
                  <div class="text-xs text-slate-400">1) 제목 개선안 3개</div>
                  <ol class="mt-2 text-sm list-decimal pl-5 space-y-1">${x.fixes.titles.map(t=>`<li class="wrap-anywhere">${escapeHtml(t)}</li>`).join("")}</ol>
                </div>
                <div class="p-3 rounded-xl bg-slate-950 border border-slate-800">
                  <div class="text-xs text-slate-400">2) 해시태그/키워드 정리안</div>
                  <div class="mt-2 text-sm wrap-anywhere">${escapeHtml(x.fixes.hashtags.join(" "))}</div>
                </div>
                <div class="p-3 rounded-xl bg-slate-950 border border-slate-800">
                  <div class="text-xs text-slate-400">3) 다음 편(후속 콘텐츠) 제안</div>
                  <ol class="mt-2 text-sm list-decimal pl-5 space-y-1">${x.fixes.sequel.map(t=>`<li class="wrap-anywhere">${escapeHtml(t)}</li>`).join("")}</ol>
                </div>
              </div>
            </div>

          </div>
        </div>
      `;
      wrap.appendChild(card);
    }

    $("underPagerInfo").textContent = `총 ${fmt.format(total)}개 · ${state.tables.under.page}/${maxPage} 페이지`;
    $("underPrev").onclick = () => { state.tables.under.page = Math.max(1, state.tables.under.page-1); renderUnderList(r); };
    $("underNext").onclick = () => { state.tables.under.page = Math.min(maxPage, state.tables.under.page+1); renderUnderList(r); };
  }

  function renderMiniSummary() {
    const r = state.mode==="bench" ? state.report.bench : state.report.mine;
    if (!r) return;
    const ch = r.channel;
    const t = `
      <b>${escapeHtml(ch.title || "채널")}</b><br/>
      - 분석 표본: <b>${fmt.format(r.kpis.count||0)}</b><br/>
      - 조회수/일 중앙값: <b>${r.kpis.medianVPD!=null ? fmt.format(Math.round(r.kpis.medianVPD)) : "—"}</b><br/>
      - Top(상위 1개): <b>${escapeHtml(r.top10[0]?.title || "—")}</b><br/>
      - Under(하위 1개): <b>${escapeHtml(r.under10[0]?.title || "—")}</b>
    `;
    $("miniSummary").innerHTML = t;
  }

  // ========= CSV (No-API) =========
  function parseCSV(text) {
    // simple CSV parser (handles quoted)
    const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
    if (!lines.length) return [];
    const header = splitCSVLine(lines[0]).map(h=>h.trim());
    const rows = [];
    for (let i=1;i<lines.length;i++) {
      const cols = splitCSVLine(lines[i]);
      const obj = {};
      header.forEach((h,idx)=> obj[h] = cols[idx] ?? "");
      rows.push(obj);
    }
    return rows;
  }

  function splitCSVLine(line) {
    const out = [];
    let cur = "", inQ=false;
    for (let i=0;i<line.length;i++) {
      const ch = line[i];
      if (ch === '"' ) {
        if (inQ && line[i+1]==='"') { cur+='"'; i++; }
        else inQ = !inQ;
      } else if (ch === ',' && !inQ) {
        out.push(cur); cur="";
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  function loadSampleNoApi() {
    // minimal mock
    const base = Date.now();
    const mk = (n, views) => ({
      videoId: "SAMPLE_"+n,
      title: n%3===0 ? `근데 이거 왜 이렇게 됐지? #shorts` : `평범한데 이상하게 기억나는 날 ${n}`,
      description: n%2===0 ? `#shorts #연애 #코미디 ${n}번째 샘플` : `#막장 #공감 샘플 ${n}`,
      publishedAt: new Date(base - n*24*3600*1000).toISOString(),
      views,
      likes: Math.round(views*0.03),
      comments: Math.round(views*0.002),
      durationSeconds: 45 + (n%4)*10,
      categoryId: "24",
      tags: ["shorts","썰","연애","코미디"],
    });
    const videos = Array.from({length:40}, (_,i)=>mk(i+1, Math.round(2000 + Math.random()*200000)));
    return {
      channel: { id:"NOAPI", snippet:{ title:"No-API 샘플 채널", publishedAt:new Date(base-400*24*3600*1000).toISOString(), description:"" }, statistics:{ subscriberCount:"0", viewCount:"0", videoCount:String(videos.length) }, contentDetails:{ relatedPlaylists:{ uploads:"" } } },
      videos: videos.map(v => ({
        id: v.videoId,
        snippet: { title: v.title, description: v.description, publishedAt: v.publishedAt, categoryId: v.categoryId, tags: v.tags },
        statistics: { viewCount: String(v.views), likeCount: String(v.likes), commentCount: String(v.comments) },
        contentDetails: { duration: "PT" + v.durationSeconds + "S" }
      })),
      categoriesMap: { "24":"Entertainment" }
    };
  }

  // ========= Convert API items to internal video rows =========
  function normalizeBundle(bundle) {
    const rule = $("selShortsRule").value;
    const threshold = Number($("selShortsThreshold").value);

    const videos = (bundle.videos||[]).map(it => {
      const sn = it.snippet || {};
      const st = it.statistics || {};
      const cd = it.contentDetails || {};

      const durationSeconds = cd.duration ? parseISODurationToSeconds(cd.duration) : (it.durationSeconds ?? null);

      const title = sn.title || it.title || "";
      const description = sn.description || it.description || "";
      const hashtags = extractHashtags(description);

      const views = st.viewCount!=null ? Number(st.viewCount) : (it.views ?? 0);
      const likes = st.likeCount!=null ? Number(st.likeCount) : (it.likes ?? null);
      const comments = st.commentCount!=null ? Number(st.commentCount) : (it.comments ?? null);

      const categoryId = sn.categoryId || it.categoryId || null;
      const tags = sn.tags || it.tags || null;

      const publishedAt = sn.publishedAt || it.publishedAt || null;

      const isShorts = classifyIsShorts({ durationSeconds, title, description }, rule, threshold);

      return {
        videoId: it.id || it.videoId,
        title,
        description,
        publishedAt,
        views,
        likes,
        comments,
        durationSeconds,
        categoryId,
        tags,
        hashtags,
        isShorts,
      };
    });

    return { channel: bundle.channel, videos, categoriesMap: bundle.categoriesMap || {} };
  }

  // ========= Compare =========
  function buildCompareReport(mine, bench) {
    if (!mine || !bench) return null;
    const out = {
      mine: {
        medianVPD: mine.kpis.medianVPD,
        shortsRatio: mine.kpis.shortsRatio,
        medianLikeRate: mine.kpis.medianLikeRate,
        uploadFreqPerWeek: mine.kpis.uploadFreqPerWeek,
        topKeyword: mine.keywords20[0]?.keyword || null
      },
      bench: {
        medianVPD: bench.kpis.medianVPD,
        shortsRatio: bench.kpis.shortsRatio,
        medianLikeRate: bench.kpis.medianLikeRate,
        uploadFreqPerWeek: bench.kpis.uploadFreqPerWeek,
        topKeyword: bench.keywords20[0]?.keyword || null
      }
    };
    out.delta = {
      medianVPD: diff(mine.kpis.medianVPD, bench.kpis.medianVPD),
      shortsRatio: diffPct(mine.kpis.shortsRatio, bench.kpis.shortsRatio),
      medianLikeRate: diff(mine.kpis.medianLikeRate, bench.kpis.medianLikeRate),
      uploadFreqPerWeek: diff(mine.kpis.uploadFreqPerWeek, bench.kpis.uploadFreqPerWeek)
    };
    return out;
  }
  function diff(a,b) {
    if (a==null || b==null) return null;
    return a - b;
  }
  function diffPct(a,b) {
    if (a==null || b==null) return null;
    return (a - b) * 100;
  }

  // ========= Analyze Flow =========
  async function runAnalyze() {
    clearError();
    clearInfo();

    // persist UI
    saveUIState();

    // quota limit sync
    state.quotaLimit = Number($("quotaLimit").value) || 10000;
    saveQuota();

    setStage("수집 준비", 0);
    startTimer();
    setProgress(1);

    try {
      let mineBundle = null, benchBundle = null;

      if (state.dataMode === "noapi") {
        setStage("No-API 로드", 5);
        // CSV or sample
        const file = $("inputCsv").files?.[0];
        if (file) {
          const text = await file.text();
          const rows = parseCSV(text);
          if (!rows.length) throw new Error("CSV가 비어있습니다. 컬럼/데이터를 확인하세요.");

          // map to internal fake bundle
          const videos = rows.map(r => ({
            id: r.videoId,
            snippet: {
              title: r.title || "",
              description: r.description || "",
              publishedAt: r.publishedAt || new Date().toISOString(),
              categoryId: r.categoryId || null,
              tags: r.tags ? r.tags.split(/[;|]/).map(s=>s.trim()).filter(Boolean) : null
            },
            statistics: {
              viewCount: String(r.views || 0),
              likeCount: r.likes ? String(r.likes) : undefined,
              commentCount: r.comments ? String(r.comments) : undefined
            },
            contentDetails: {
              duration: r.durationSeconds ? ("PT"+Number(r.durationSeconds)+"S") : "PT0S"
            }
          }));

          mineBundle = {
            channel: { id:"NOAPI", snippet:{ title:"No-API(CSV)", publishedAt:new Date().toISOString(), description:"" }, statistics:{ videoCount:String(videos.length) }, contentDetails:{ relatedPlaylists:{ uploads:"" } } },
            videos,
            categoriesMap: {}
          };
        } else {
          mineBundle = loadSampleNoApi();
        }

        // normalize + report
        const nb = normalizeBundle(mineBundle);
        state.dataset.mine = nb;
        setStage("분석", 70);
        state.report.mine = buildReport(nb);
        state.report.bench = null;
        state.report.compare = null;

        setProgress(95);
        renderAll();
        setStage("완료", 100);
        stopTimer();
        return;
      }

      // API mode
      const cacheHours = Number($("inputCacheHours").value || 6);
      const forceCache = $("optForceCache").checked;

      // Mine
      const inMine = normalizeChannelInput($("inputMine").value);
      if (inMine.kind==="empty") throw new Error("내 채널 입력이 비어있습니다.");

      setStage("식별(내 채널)", 5);
      const mineResolved = await resolveChannelId(inMine, cacheHours, forceCache);

      setStage("수집(내 채널)", 10);
      const mineRaw = await fetchChannelBundle(mineResolved.channelId, cacheHours, forceCache);
      mineBundle = normalizeBundle(mineRaw);
      state.dataset.mine = mineBundle;

      // Bench if needed
      if (state.mode !== "mine") {
        const inBench = normalizeChannelInput($("inputBench").value);
        if (inBench.kind==="empty") throw new Error("벤치 채널 입력이 비어있습니다.");
        setStage("식별(벤치 채널)", 40);
        const benchResolved = await resolveChannelId(inBench, cacheHours, forceCache);

        setStage("수집(벤치 채널)", 45);
        const benchRaw = await fetchChannelBundle(benchResolved.channelId, cacheHours, forceCache);
        benchBundle = normalizeBundle(benchRaw);
        state.dataset.bench = benchBundle;
      } else {
        state.dataset.bench = null;
      }

      // Analysis
      setStage("정제/분석", 80);
      state.report.mine = buildReport(mineBundle);
      state.report.bench = benchBundle ? buildReport(benchBundle) : null;
      state.report.compare = (state.mode==="compare") ? buildCompareReport(state.report.mine, state.report.bench) : null;

      setProgress(95);
      renderAll();
      setStage("완료", 100);
      stopTimer();
    } catch (e) {
      stopTimer();
      setStage("실패", 0);
      setProgress(0);

      const msg = String(e?.message || e);
      setError(`
        <b>오류</b><br/>
        <div class="mono wrap-anywhere mt-2">${escapeHtml(msg)}</div>
        <div class="mt-3 text-slate-200">
          <b>해결 방법</b><br/>
          - 채널 URL이 <span class="mono">/channel/UC...</span> 또는 <span class="mono">/@handle</span> 형태인지 확인<br/>
          - 핸들 오타(@ 포함) 여부 확인, 또는 채널ID(UC...)로 재시도<br/>
          - API 모드에서 쿼터가 부족하면: 최근 N 줄이기 / 캐시 사용 / 다음날(PT 기준) 재시도<br/>
          - No-API 모드라면: CSV 컬럼명을 맞춰 업로드
        </div>
      `);
    }
  }

  function renderAll() {
    const r = (state.mode==="bench") ? state.report.bench : state.report.mine;
    renderKPIs(r);
    renderGoodBad(r);
    renderPatterns(r);
    renderTopTable(r);
    renderUnderList(r);
    renderMiniSummary();

    // GPT preview
    const pack = buildGptPack($("selPromptType").value);
    const prompt = buildGptPrompt($("selPromptType").value);
    state.lastPack = pack;
    state.lastPrompt = prompt;
    $("previewText").value = JSON.stringify(pack, null, 2).slice(0, 5000);

    // compare info
    if (state.mode==="compare" && state.report.compare) {
      setInfo(`
        <b>Compare 요약</b><br/>
        - 조회수/일 중앙값 차이(내-벤치): <b>${state.report.compare.delta.medianVPD!=null ? fmt.format(Math.round(state.report.compare.delta.medianVPD)) : "—"}</b><br/>
        - 쇼츠 비율 차이(내-벤치): <b>${state.report.compare.delta.shortsRatio!=null ? state.report.compare.delta.shortsRatio.toFixed(1)+"%p" : "—"}</b><br/>
        - 업로드 빈도/주 차이(내-벤치): <b>${state.report.compare.delta.uploadFreqPerWeek!=null ? state.report.compare.delta.uploadFreqPerWeek.toFixed(2) : "—"}</b>
      `);
    } else {
      clearInfo();
    }
  }

  // ========= XLSX Export =========
  function openExportModal() {
    $("exportModal").classList.remove("hidden");
    $("exportModal").classList.add("flex");
  }
  function closeExportModal() {
    $("exportModal").classList.add("hidden");
    $("exportModal").classList.remove("flex");
  }

  function exportXlsx(scope) {
    const r = (state.mode==="bench") ? state.report.bench : state.report.mine;
    if (!r) { toast("내보낼 데이터가 없습니다"); return; }

    const rows = (scope==="current") ? applyFilters(state.dataset.mine?.videos||[]).map(v=>v) : (state.dataset.mine?.videos||[]);
    // rebuild minimal export rows from report rows (current filter already in report)
    const exportRows = (scope==="current" ? r.rows : r.rows).map(x=>({
      videoId: x.videoId,
      title: x.title,
      views: x.views,
      viewsPerDay: x.vpd,
      likeRate: x.likeRate,
      commentRate: x.commentRate,
      category: x.category,
      publishedAt: x.publishedAt,
      url: x.url,
      hashtags: (x.hashtags||[]).join(" "),
      tags: Array.isArray(x.tags) ? x.tags.join(";") : (x.tags||""),
      durationSeconds: x.durationSeconds,
      isShorts: x.isShorts,
      score: x.score,
      bucket: x.bucket
    }));

    const top = r.top10.map(x=>({
      videoId: x.videoId, title: x.title, views: x.views, viewsPerDay: x.vpd, score: x.score, url: x.url
    }));
    const under = buildUnderDiagnoses(r).map(x=>({
      videoId: x.videoId, title: x.title, views: x.views, viewsPerDay: x.vpd, score: x.score, url: x.url,
      reasons_profile: (x.reasons.profile||[]).join(" | "),
      reasons_auto: (x.reasons.auto||[]).join(" | "),
      fix_titles: (x.fixes.titles||[]).join(" / "),
      fix_hashtags: (x.fixes.hashtags||[]).join(" "),
      fix_sequel: (x.fixes.sequel||[]).join(" / ")
    }));

    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(exportRows), "videos");
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(top), "top10");
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(under), "under10");
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(r.keywords20), "keywords20");

    const fname = `yt_analyzer_${(r.channel?.title||"channel").replace(/[^\p{L}\p{N}_-]/gu,'_')}_${new Date().toISOString().slice(0,10)}.xlsx`;
    XLSX.writeFile(wb, fname);
  }

  // ========= Events =========
  document.querySelectorAll(".modeBtn").forEach(b => b.onclick = () => { setMode(b.dataset.mode); saveUIState(); });

  $("btnCriteriaProfile").onclick = () => { setCriteria("profile"); saveUIState(); renderAll(); };
  $("btnCriteriaAuto").onclick = () => { setCriteria("auto"); saveUIState(); renderAll(); };

  $("btnDataApi").onclick = () => { setDataMode("api"); saveUIState(); };
  $("btnDataNoApi").onclick = () => { setDataMode("noapi"); saveUIState(); };

  $("toggleJsonOut").onclick = () => { toggleJsonOut(!state.jsonOut); saveUIState(); };

  $("quotaLimit").onchange = () => { state.quotaLimit = Number($("quotaLimit").value)||10000; saveQuota(); renderQuota(); };

  document.querySelectorAll(".viewPreset").forEach(b => b.onclick = () => {
    $("inputMinViews").value = b.dataset.min;
    $("inputMaxViews").value = "";
  });
  $("btnClearViewPreset").onclick = () => { $("inputMinViews").value = ""; $("inputMaxViews").value = ""; };

  $("btnAnalyze").onclick = runAnalyze;

  $("topSearch").oninput = debounce(() => { state.tables.top.query = $("topSearch").value; state.tables.top.page=1; renderTopTable((state.mode==="bench")?state.report.bench:state.report.mine); }, 200);
  $("topPageSize").onchange = () => { state.tables.top.pageSize = Number($("topPageSize").value); state.tables.top.page=1; renderTopTable((state.mode==="bench")?state.report.bench:state.report.mine); };

  $("underSearch").oninput = debounce(() => { state.tables.under.query = $("underSearch").value; state.tables.under.page=1; renderUnderList((state.mode==="bench")?state.report.bench:state.report.mine); }, 200);
  $("underPageSize").onchange = () => { state.tables.under.pageSize = Number($("underPageSize").value); state.tables.under.page=1; renderUnderList((state.mode==="bench")?state.report.bench:state.report.mine); };

  $("selPromptType").onchange = () => {
    const pack = buildGptPack($("selPromptType").value);
    const prompt = buildGptPrompt($("selPromptType").value);
    state.lastPack = pack; state.lastPrompt = prompt;
    $("previewText").value = JSON.stringify(pack, null, 2).slice(0, 5000);
  };

  $("btnCopyPack").onclick = async () => {
    const pack = state.lastPack || buildGptPack($("selPromptType").value);
    const text = JSON.stringify(pack, null, 2);
    await copyToClipboard(text);
  };

  $("btnCopyPrompt").onclick = async () => {
    const prompt = state.lastPrompt || buildGptPrompt($("selPromptType").value);
    await copyToClipboard(prompt);
  };

  $("btnExportXlsx").onclick = openExportModal;
  $("btnCloseExport").onclick = closeExportModal;
  $("btnDoExport").onclick = () => {
    const scope = $("expAll").checked ? "all" : "current";
    exportXlsx(scope);
    closeExportModal();
  };

  $("btnOpenProfile").onclick = openProfileModal;
  $("btnCloseProfile").onclick = closeProfileModal;

  $("btnSaveProfile").onclick = () => { saveEditorToProfile(); toast("프로필 저장 완료"); };
  $("btnDeleteProfile").onclick = () => {
    if (state.profiles.length<=1) { toast("최소 1개 프로필은 필요합니다"); return; }
    const id = state.activeProfileId;
    state.profiles = state.profiles.filter(p=>p.id!==id);
    state.activeProfileId = state.profiles[0].id;
    saveProfiles(true);
    renderProfileList();
    loadProfileToEditor(getActiveProfile());
    toast("프로필 삭제 완료");
  };

  $("btnNewProfile").onclick = () => {
    const base = JSON.parse(JSON.stringify(getActiveProfile()));
    base.id = "pf_" + Math.random().toString(36).slice(2,10);
    base.name = "새 프로필";
    state.profiles.unshift(base);
    state.activeProfileId = base.id;
    saveProfiles(true);
    renderProfileList();
    loadProfileToEditor(base);
    toast("새 프로필 생성");
  };

  $("btnAddWeightKey").onclick = () => {
    const k = $("newWeightKey").value.trim();
    if (!k) return;
    const prof = getActiveProfile();
    if (prof.weights[k]!=null) { toast("이미 존재하는 항목"); return; }
    prof.weights[k] = 3;
    $("newWeightKey").value = "";
    renderWeightGrid(prof);
  };

  // sliders live labels
  ["age10","age20","age30","age40","male","female"].forEach(id=>{
    $(id).oninput = () => $(id+"v").textContent = $(id).value;
  });

  // Export/Import profile JSON
  $("btnExportProfileJson").onclick = async () => {
    const data = { profiles: state.profiles, activeProfileId: state.activeProfileId };
    await copyToClipboard(JSON.stringify(data, null, 2));
  };

  $("btnImportProfileJson").onclick = async () => {
    const raw = prompt("가져올 프로필 JSON을 붙여넣으세요");
    if (!raw) return;
    try {
      const obj = JSON.parse(raw);
      if (!obj.profiles || !Array.isArray(obj.profiles) || !obj.profiles.length) throw new Error("profiles 배열이 없습니다");
      state.profiles = obj.profiles;
      state.activeProfileId = obj.activeProfileId && obj.profiles.some(p=>p.id===obj.activeProfileId) ? obj.activeProfileId : obj.profiles[0].id;
      saveProfiles(true);
      renderProfileList();
      loadProfileToEditor(getActiveProfile());
      toast("프로필 JSON 가져오기 완료");
    } catch (e) {
      toast("가져오기 실패: " + (e.message||e));
    }
  };

  // No-API sample button
  $("btnLoadSample").onclick = () => {
    const b = loadSampleNoApi();
    const nb = normalizeBundle(b);
    state.dataset.mine = nb;
    state.report.mine = buildReport(nb);
    state.mode = "mine";
    setMode("mine");
    renderAll();
    toast("샘플 데이터 로드 완료");
  };

  // ========= Init =========
  loadProfiles();
  loadQuota();
  loadUIState();

  // defaults
  setMode(state.mode);
  setCriteria(state.criteria);
  setDataMode(state.dataMode);
  toggleJsonOut(state.jsonOut);

})();
</script>
</body>
</html>
